<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Purpose of the compiler is\nto detect non-valid programs to translate to valid ones Lexical Analysis partition the strings into tokens\nToken Class: Identifier, Keyword &mldr;\nRegular Languages Def. The regular expressions over $\\sum$ are the smallest set of expressions including\nUnion Concatenation Iteration Formal Languages Def. Let $\\sum$ be a set of characters (an alphabet). A language over $\\sum$ is a set of strings of characters drawn from $\\sum$\n"><title>【Stanford Compilers】Notes</title>
<link rel=canonical href=https://dyhes.github.io/p/stanford-compilersnotes/><link rel=stylesheet href=/scss/style.min.6aa4d43a5cae1c51ef34b3f851ae7421f4b2f2d13827e2d975acbeb4f13c8710.css><meta property='og:title' content="【Stanford Compilers】Notes"><meta property='og:description' content="Purpose of the compiler is\nto detect non-valid programs to translate to valid ones Lexical Analysis partition the strings into tokens\nToken Class: Identifier, Keyword &mldr;\nRegular Languages Def. The regular expressions over $\\sum$ are the smallest set of expressions including\nUnion Concatenation Iteration Formal Languages Def. Let $\\sum$ be a set of characters (an alphabet). A language over $\\sum$ is a set of strings of characters drawn from $\\sum$\n"><meta property='og:url' content='https://dyhes.github.io/p/stanford-compilersnotes/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2023-06-06T00:00:00+00:00'><meta property='article:modified_time' content='2023-06-06T00:00:00+00:00'><meta name=twitter:title content="【Stanford Compilers】Notes"><meta name=twitter:description content="Purpose of the compiler is\nto detect non-valid programs to translate to valid ones Lexical Analysis partition the strings into tokens\nToken Class: Identifier, Keyword &mldr;\nRegular Languages Def. The regular expressions over $\\sum$ are the smallest set of expressions including\nUnion Concatenation Iteration Formal Languages Def. Let $\\sum$ be a set of characters (an alphabet). A language over $\\sum$ is a set of strings of characters drawn from $\\sum$\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu17834253352308399148.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#lexical-analysis>Lexical Analysis</a><ol><li><a href=#regular-languages><strong>Regular Languages</strong></a></li><li><a href=#formal-languages><strong>Formal Languages</strong></a></li><li><a href=#lexical-specification><strong>Lexical Specification</strong></a></li><li><a href=#finite-automata><strong>Finite Automata</strong></a><ol><li><a href=#deterministic-finite-automatadfa><strong>Deterministic Finite Automata(DFA)</strong></a></li><li><a href=#nondeterministic-finite-automatanfa><strong>Nondeterministic Finite Automata(NFA)</strong></a></li></ol></li></ol></li><li><a href=#syntactic-analysis-parsing>Syntactic Analysis (Parsing)</a><ol><li><a href=#cfg><strong>CFG</strong></a></li><li><a href=#derivations>Derivations</a></li><li><a href=#parse-tree>Parse Tree</a></li><li><a href=#ambiguity>Ambiguity</a></li><li><a href=#error-handling>Error Handling</a><ol><li><a href=#panic-mode>Panic mode</a></li><li><a href=#error-productions>Error productions</a></li><li><a href=#abstract-syntax-tree>Abstract Syntax Tree</a></li></ol></li><li><a href=#recursive-descent-algorithm>Recursive Descent Algorithm</a></li><li><a href=#predictive-parser>Predictive Parser</a><ol><li><a href=#first-set><strong>First Set</strong></a></li><li><a href=#follow-set>Follow Set</a></li><li><a href=#parsing-table>Parsing Table</a></li></ol></li><li><a href=#bottom-up-parsing>Bottom-Up Parsing</a><ol><li><a href=#viable-prefix>viable prefix</a></li><li><a href=#recognizing-vp>Recognizing VP</a></li><li><a href=#lr0-parsing>LR(0) Parsing</a></li><li><a href=#slr-parsing>SLR Parsing</a></li></ol></li></ol></li><li><a href=#semantic-analysis>Semantic Analysis</a><ol><li><a href=#scope>Scope</a></li><li><a href=#symbol-tables>Symbol Tables</a></li><li><a href=#types>Types</a><ol><li><a href=#type-checking>Type Checking</a></li><li><a href=#type-environment>Type environment</a></li><li><a href=#subtyping>Subtyping</a></li><li><a href=#typing-methods>Typing Methods</a></li><li><a href=#general-themes>General themes</a></li><li><a href=#self_type>SELF_TYPE</a></li></ol></li></ol></li><li><a href=#code-generation>Code Generation</a><ol><li><a href=#activations>Activations</a><ol><li><a href=#activation-record-ar>Activation Record (AR)</a></li></ol></li><li><a href=#globals--heap>Globals & Heap</a></li><li><a href=#alignment>Alignment</a></li><li><a href=#stack-machines>Stack Machines</a><ol><li><a href=#code-generation-1>code generation</a></li></ol></li><li><a href=#variables>variables</a></li><li><a href=#temporaries>temporaries</a></li><li><a href=#object-layout>Object Layout</a></li></ol></li><li><a href=#semantics>Semantics</a><ol><li><a href=#operational-semantics>Operational Semantics</a></li></ol></li><li><a href=#intermediate-code>Intermediate Code</a></li><li><a href=#optimization>Optimization</a><ol><li><a href=#basic-block>Basic Block</a></li><li><a href=#control-flow-graph>control-flow graph</a></li><li><a href=#granularity>Granularity</a></li><li><a href=#local-optimization>Local Optimization</a><ol><li><a href=#peephole-optimization>Peephole optimization</a></li></ol></li><li><a href=#global-optimization>Global Optimization</a><ol><li><a href=#dataflow-analysis>Dataflow Analysis</a></li></ol></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/star/ style=background-color:#2e317c;color:>一天星</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/stanford-compilersnotes/>【Stanford Compilers】Notes</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 06, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>19 minute read</time></div></footer></div></header><section class=article-content><p>Purpose of the compiler is</p><ul><li>to detect non-valid programs</li><li>to translate to valid ones</li></ul><h2 id=lexical-analysis>Lexical Analysis</h2><p>partition the strings into tokens</p><p><strong>Token Class</strong>: Identifier, Keyword &mldr;</p><h3 id=regular-languages><strong>Regular Languages</strong></h3><p>Def. The regular expressions over $\sum$ are the smallest set of expressions including</p><ul><li>Union</li><li>Concatenation</li><li>Iteration</li></ul><h3 id=formal-languages><strong>Formal Languages</strong></h3><p>Def. Let $\sum$ be a set of characters (an alphabet). A language over $\sum$ is <strong>a set of strings of characters</strong> drawn from $\sum$</p><blockquote><p>A regular language is a type of formal language that <strong>can be generated by a regular expression or recognized by a finite automaton (FA)</strong>. Regular languages are a subset of the class of formal languages.</p></blockquote><blockquote><p>meaning(mapping from syntax to semantics) is many to one rather than one to many.</p></blockquote><h3 id=lexical-specification><strong>Lexical Specification</strong></h3><ul><li><p>maximal match</p></li><li><p>prioritized match</p></li><li><p>Error match</p><p>Error = {all strings not in the lexical specification}</p></li></ul><h3 id=finite-automata><strong>Finite Automata</strong></h3><ul><li>regular expressions = specification</li><li>finite automata = implementation</li></ul><p>a finite automaton consists of</p><ul><li>An input alphabet $\sum$</li><li>A set of states $S$</li><li>A start state $n$</li><li>A set of accepting states $F\subseteq S$</li><li>A set of transitions $state \rightarrow^{input} state$</li></ul><h4 id=deterministic-finite-automatadfa><strong>Deterministic Finite Automata(DFA)</strong></h4><ul><li>one transition per input per state</li><li>No $\epsilon-$moves</li></ul><h4 id=nondeterministic-finite-automatanfa><strong>Nondeterministic Finite Automata(NFA)</strong></h4><ul><li>can have multiple transitions for one input in a given state</li><li>can have $\epsilon-$moves</li></ul><p>DFAs are faster to execute</p><p><img src=https://i.ibb.co/VQvZzgS/image-20230310211302078.png loading=lazy alt=image-20230310211302078></p><h5 id=subset-method-for-nfa-determinization><strong>Subset Method for NFA Determinization</strong></h5><ul><li>$\epsilon-closure$</li><li>transition</li></ul><h5 id=partition-method-for-dfa-minimization><strong>Partition Method for DFA Minimization</strong></h5><h2 id=syntactic-analysis-parsing>Syntactic Analysis (Parsing)</h2><h3 id=cfg><strong>CFG</strong></h3><p>CFG (context-free grammars) are a natural notation for the recursive structure of programming languages.</p><p>A CFG consists of</p><ul><li>A set of terminals $T$</li><li>A set of non-terminals $N$</li><li>A start symbol $S$</li><li>A set of productions (Productions can be read as rules)</li></ul><p><strong>steps:</strong></p><ol><li>Begin with a string with only the start symbol $S$</li><li>Replace any non-terminal $X$ in the string by the right-hand side of some production $X \rightarrow Y_1&mldr;Y_n$</li><li>Repeat 2. until there are no non-terminals</li></ol><p>Def. Let $G$ be a context-free grammar with start symbol $S$. Then the language $L(G)$ of $G$ is:
$$
{a_1&mldr;a_n| a}
$$</p><ul><li>Terminals are so-called because there are no rules for replacing them</li><li>Once generated, terminals are permanent</li><li>Terminals ought to be tokens of the language</li></ul><h3 id=derivations>Derivations</h3><p>A derivation is a sequence of productions
$$
S\rightarrow &mldr; \rightarrow &mldr; \rightarrow &mldr; \rightarrow &mldr;
$$
A derivation can be drawn as a tree</p><ul><li>start symbol is the tree&rsquo;s root</li><li>For a production $X\rightarrow Y_1&mldr;Y_n$ add children $Y_1&mldr;Y_n$ to node $X$</li></ul><p>left-most derivation: at each step, replace the left-most non-terminal</p><p>right-most derivation: at each step, replace the right-most non-terminal</p><blockquote><p>right-most and left-most derivations have the same parse tree</p></blockquote><h3 id=parse-tree>Parse Tree</h3><p>A parse tree has</p><ul><li>terminals at the leaves</li><li>non-terminals at the interior nodes</li></ul><p>A in-order traversal of the leaves is the original input</p><p>The parse tree shows the association of operations, the input string does not</p><h3 id=ambiguity>Ambiguity</h3><p>A grammar is ambiguous if it has more than one parse tree for some string. Equivalently, there is more than one right-most or left-most derivation for some string</p><ul><li>Impossible to convert automatically an ambiguous grammar to an unanbiguous one</li><li>Used with care, ambiguity can simplify the grammar<ul><li>sometimes allows more natural definitions</li><li>we need disambiguation mechanisms</li></ul></li><li>most tools allow <strong>precedence and associativity declarations</strong> to disambiguate grammars</li></ul><h3 id=error-handling>Error Handling</h3><h4 id=panic-mode>Panic mode</h4><ul><li>when an error is detected:<ul><li>discard tokens until one with a clear role is found</li><li>continue from there</li></ul></li><li>Looking for synchronizing tokens<ul><li>typically the statement or expression terminators</li></ul></li></ul><h4 id=error-productions>Error productions</h4><p>specify known common mistakes in the grammar</p><h4 id=abstract-syntax-tree>Abstract Syntax Tree</h4><p>Like parse trees but ignore some details</p><p><strong>A parse tree</strong></p><ul><li>Traces the operation of the parser</li><li>Captures nesting structure</li><li>But too much information<ul><li>Parentheses</li><li>Single-successor nodes</li></ul></li></ul><p><strong>Abstract Syntax Tree</strong></p><ul><li>Also captures the nesting structure</li><li>But abstracts from the concrete syntax<ul><li>more compact and easier to use</li></ul></li><li>An important data structure in a compiler</li></ul><h3 id=recursive-descent-algorithm>Recursive Descent Algorithm</h3><ul><li>The parse tree is constructed<ul><li>from the top to down</li><li>from left to right</li></ul></li><li>Terminals are seen in order of appearance in the token stream</li></ul><p><img src=https://i.ibb.co/tYRgn6W/image-20230311164126008.png loading=lazy alt=image-20230311164126008></p><p><strong>Limitation</strong></p><ul><li>if a production for non-terminal X succeeds cannot backtrack to try a different production for X later</li><li>Left-recursion must be eliminated first</li></ul><p>sufficient for grammars where for any non-terminal at most one production can succeed</p><p><strong>left recursion</strong></p><p>eg: $S->Sa$, can be eliminated</p><h3 id=predictive-parser>Predictive Parser</h3><p>like recursive-descent but parser can &ldquo;predict&rdquo; which production to use</p><ul><li>by looking at the next few tokens</li><li>no backtracking</li></ul><p>Predictive parsers accept LL(k) (<strong>left-to-right left-most k-tokens-lookahead</strong>) grammars</p><p>LL(1): at each step, only one choice of production</p><p><strong>left-factoring</strong>: to eliminate the common prefixes of multiple productions for one non-terminal</p><p>steps:</p><ul><li>for the leftmost non-terminal $S$</li><li>look at the next input token $a$</li><li>choose the production shown at $[S, a]$ (parsing table)</li><li>reject on reaching error state</li><li>accept on end of input & empty stack</li></ul><p>use a stack to record frontier of parse tree</p><p>frontier:</p><ul><li>non-terminals that have yet to be expanded</li><li>terminals that have yet to matched against the input</li></ul><p>top of stack: leftmost pending terminal or non-terminal</p><ul><li>consider non-terminal $A$, production $A\rightarrow \alpha$ and token $t$</li><li>$T[A,t] = \alpha$ in two cases:</li><li>if $\alpha \rightarrow^{*} t\beta$<ul><li>$\alpha$ can derive a $t$ in the first position</li><li>we say that $t\in First(\alpha)$</li></ul></li><li>if $A\rightarrow \alpha$ and $\alpha \rightarrow^{<em>} \epsilon$ and $S\rightarrow^{</em>} \beta A t \delta$<ul><li>useful if stack has $A$, input is $t$, and $A$ cannot derive $t$</li><li>in this case only option is to get rid of $A$ (by deriving $\epsilon$) : can work only if $t$ can follow $A$ in at least one derivation</li><li>We say that $t\in Follow(A)$</li></ul></li></ul><h4 id=first-set><strong>First Set</strong></h4><p>Def.
$$
First(X)={t|X\rightarrow^{<em>}t\alpha}\cup{\epsilon | X\rightarrow^{</em>}\epsilon}
$$
<strong>Algorithm</strong></p><ul><li>$First(t)={t}$</li><li>$\epsilon\in First(X)$<ul><li>if $X\rightarrow \epsilon$</li><li>if $X\rightarrow A_1&mldr;A_n$ and $\epsilon\in First(A_i)$ for $1\le i \le n$</li></ul></li><li>$First(\alpha)\subseteq First(X)$ if $X\rightarrow A_1&mldr;A_n\alpha$ and $\epsilon\in First(A_i)$ for $1\le i \le n$</li></ul><h4 id=follow-set>Follow Set</h4><p>Def.
$$
Follow(X) = {t|S\rightarrow^{*} \beta A t \delta}
$$
intuition</p><ul><li>if $X\rightarrow AB$ then $First(B)\subseteq Follow(A)$ and $Follow(X)\subseteq Follow(B)$</li><li>if $B\rightarrow^{*}\epsilon$ then $Follow(X)\subseteq Follow(A)$</li><li>if $S$ is the start symbol then $$\in Follow(S)$</li></ul><p>Algorithm</p><ul><li>$$\in Follow(S)$</li><li>$First(\beta) -{\epsilon}\subseteq Follow(X)$ for each production $A\rightarrow\alpha X\beta$</li><li>$Follow(A)\subseteq Follow(X)$ for each production $A\rightarrow \alpha X\beta$ where $\epsilon\in First(\beta)$</li></ul><h4 id=parsing-table>Parsing Table</h4><p>for each production $A\rightarrow \alpha$ in G do:</p><ul><li>for each terminal $t\in First(\alpha)$ do $T[A,t] = \alpha$</li><li>if $\epsilon\in First(\alpha)$, for each $t\in Follow(A)$ do $T[A,t] = \alpha$</li><li>if $\epsilon \in First(\alpha)$ and $$\in Follow(A)$ do $T[A,$] = \alpha$</li></ul><p>LL(1) Table</p><ul><li>if any entry is multiply defined then G is not LL(1)</li><li>Most programming language CFGs are not LL(1)</li></ul><h3 id=bottom-up-parsing>Bottom-Up Parsing</h3><ul><li>Bottom-Up parsing is more general than (deterministic) top-down parsing</li><li>Bottom-Up is the preferred method</li><li>Bottom-Up parsing reduces a string to the start symbol by inverting productions</li><li>A bottom-up parser traces a rightmost derivation in reverse</li><li>Bottom-up parsing uses only two kinds of actions<ul><li>Shift</li><li>Reduce</li></ul></li></ul><p><strong>shift-reduce conflict</strong>: it is legal to shift or reduce</p><p><strong>reduce-reduce conflict</strong>: it is legal to reduce by two different productions (bad)</p><p><strong>Handle</strong>: a reduction that also allows further reductions back to the start symbol</p><ul><li>handles always appear at the top of the stack</li><li>never to the left of the rightmost non-terminal</li></ul><p>Bottom-up parsing algorithms are based on recognizing handles</p><h4 id=viable-prefix>viable prefix</h4><p>Def. $\alpha$ is a viable prefix if there is an $\omega$ such that $\alpha|\omega$ is a state of a shift-reduce parser</p><ul><li>a viable prefix does not extend past the right end of the handle</li><li>viable prefix is a prefix of the handle</li><li>as long as a parser has viable prefixes on the stack no parsing error has been detected</li></ul><blockquote><p>For any grammar, the set of viable prefixes is a regular language</p></blockquote><h4 id=recognizing-vp>Recognizing VP</h4><p>steps:</p><ul><li><p>add a dummy production $S^{&rsquo;}\rightarrow S$ to $G$</p></li><li><p>The NFA states are the items of $G$</p></li><li><p>for item $E\rightarrow \alpha .X\beta$ add transition:
$$
(E\rightarrow \alpha.X\beta)\rightarrow^{X}(E\rightarrow \alpha X.\beta)
$$</p></li><li><p>For item $E\rightarrow \alpha.X\beta$ and production $X\rightarrow \gamma$ add
$$
(E\rightarrow \alpha.X\beta)\rightarrow^{\epsilon}(X\rightarrow.\gamma)
$$</p></li><li><p>every state is an accepting state</p></li><li><p>start state is $S^{&rsquo;}\rightarrow .S$</p></li></ul><h4 id=lr0-parsing>LR(0) Parsing</h4><p>LR(0) Parsing steps:</p><ul><li>LR(0) Parsing: Assume<ul><li>stack contains $\alpha$</li><li>next input is $t$</li><li>DFA on input $\alpha$ terminates in state $s$</li></ul></li><li>Reduce by $X\rightarrow\beta$ if<ul><li>$s$ contains item $X\rightarrow\beta.$</li></ul></li><li>Shift if<ul><li>$s$ contains item $X\rightarrow\beta.t\omega$</li><li>equivalent to saying $s$ has a transition labeled $t$</li></ul></li><li>LR(0) gas a reduce/reduce conflict if:<ul><li>any state has two reduce items</li><li>$X\rightarrow \beta.$ and $Y\rightarrow \omega$</li></ul></li><li>LR(0) has a shift/reduce conflict if:<ul><li>any state has a reduce item and a shift item</li><li>$X\rightarrow \beta.$ and $Y\rightarrow\omega .t \delta$</li></ul></li></ul><h4 id=slr-parsing>SLR Parsing</h4><p>simple left-to-right right-most parsing</p><ul><li>Assume<ul><li>stack contains $\alpha$</li><li>next input is $t$</li><li>DFA on input $\alpha$ terminates in state $s$</li></ul></li><li>Reduce by $X\rightarrow\beta$ if<ul><li>$s$ contains item $X\rightarrow\beta.$ and $t\in Follow(X)$</li></ul></li><li>Shift if<ul><li>$s$ contains item $X\rightarrow\beta.t\omega$</li><li>equivalent to saying $s$ has a transition labeled $t$</li></ul></li><li>LR(0) gas a reduce/reduce conflict if:<ul><li>any state has two reduce items</li><li>$X\rightarrow \beta.$ and $Y\rightarrow \omega$</li></ul></li><li>LR(0) has a shift/reduce conflict if:<ul><li>any state has a reduce item and a shift item</li><li>$X\rightarrow \beta.$ and $Y\rightarrow\omega .t \delta$</li></ul></li></ul><p>steps:</p><ul><li>let $M$ be DFA for viable prefixes of $G$</li><li>let $|x_1&mldr;x_n$$ be initial configuration</li><li>repeat until configuration is $S|$$<ul><li>let $\alpha|\omega$ be current configuration</li><li>run $M$ on current stack $\alpha$</li><li>if $M$ rejects $\alpha$, report parsing error</li><li>if $M$ accepts $\alpha$ with items $I$, let $a$ be next input<ul><li>shift if $X\rightarrow \beta.a\gamma\in I$</li><li>reduce if $X\rightarrow \beta.\in I$ and $a\in Follow(X)$</li><li>report parsing error if neither applies</li></ul></li></ul></li></ul><h5 id=improvement>Improvement</h5><p>change stack to contain pairs
$$
&lt;Symbol,DFA\space State>
$$
the bottom of the stack is $&lt;any, start>$ where</p><ul><li><p>$any$ is any dummy symbol</p></li><li><p>$start$ is the start of state of the DFA</p></li><li><p>Define $goto[i,A]=j$ if $state_i\rightarrow^{A}state_j$</p></li><li><p>$goto$ is just the transition function of the DFA</p></li></ul><h2 id=semantic-analysis>Semantic Analysis</h2><p>last &ldquo;front end&rdquo; phase</p><p>catches all remaining errors</p><h3 id=scope>Scope</h3><p>matching identifier declarations with uses</p><p>the scope of an identifier is <strong>the portion of a program in which that identifier is accessible</strong></p><p>most languages have static scope: scope depends only on the program text, not run-time behavior</p><p>a few languages are dynamically scoped: scope depends on execution of the program</p><h3 id=symbol-tables>Symbol Tables</h3><p>much of semantic analysis can be expressed as a recursive descent of an AST</p><p>A symbol table is a data structure that tracks the current bindings of identifiers</p><h3 id=types>Types</h3><ul><li>the notion varies from language to language</li><li>consensus<ul><li>a set of values</li><li>a set of operations on those values</li></ul></li><li>classes are one instantiation of the modern notion of type</li></ul><p>the goal of type checking is to ensure that operations are used with the correct types</p><p>three kinds of languages:</p><ul><li>Statically typed: all or almost all checking of types is done as part of compilation (C, Java)</li><li>Dynamically typed: Almost all checking of types is done as part of program execution</li><li>Untyped: No type checking (machine code)</li></ul><p>A lot of code is written in statically typed languages with an &ldquo;escape&rdquo; mechanism</p><ul><li>Type Checking is the process of verifying fully typed programs</li><li>Type Inference is the process of filling in missing type information</li><li>The two are different, but the terms are often used interchangeably</li></ul><h4 id=type-checking>Type Checking</h4><p>A type system is sound if</p><ul><li>whenever $\vdash e: T$</li><li>then $e$ evaluates to a value of type $T$</li></ul><p>we only want sound rules, but some sound rules are better than others</p><p>Type checking proves fact $e: T$</p><ul><li>proof is on the structure of the AST</li><li>proof has the shape of the AST</li><li>one type rule is used for each AST node</li></ul><p>in the type rule used for a node $e$:</p><ul><li>Hypotheses are the proofs of types of $e$&rsquo;s subexpressions</li><li>conclusion is the type of $e$</li></ul><p>types are computed in a bottom-up pass over the AST</p><h4 id=type-environment>Type environment</h4><p>a type environment gives types for free variables</p><ul><li>a type environment is a function from Object Identifiers to Types</li><li>A variable is <strong>free</strong> in an expression if it is not defined within the expression</li></ul><p>let $O$ be a function from $ObjectIdentifiers$ to $Types$</p><p>the sentence $O \vdash e: T$ is read: Under the assumption that variables have the types given by $O$, it is provable that the expression $e$ has the type $T$</p><p>and we can write new rules:
$$
\frac{O(x)=T}{O\vdash x: T}
$$
The type environment is passed down the AST from the root towards the leaves</p><p>Types are computed up the AST from the leaves towards the root</p><h4 id=subtyping>Subtyping</h4><p>Define a relation $\le$ on classes</p><ul><li>$X\le X$</li><li>$X\le Y$ if $X$ inherits from $Y$</li><li>$X\le Z$ if $X\le Y$ and $Y\le Z$</li></ul><h4 id=typing-methods>Typing Methods</h4><p>method environment $M$</p><h4 id=general-themes>General themes</h4><ul><li>Type rules are defined on the structure of expressions</li><li>Types of variables are modeled by an environment</li><li>cam be implemented in a single traversal over the AST</li><li>Type environment is passes down the tree</li><li>Types are passed up the tree</li></ul><h4 id=self_type>SELF_TYPE</h4><p>if $SELF_TYPE $ appears textually in the class $C$ as the declared type of $E$ then
$$
dynamic_type(E)\le C
$$</p><ul><li>in type checking it is always safe to replace $SELF_TYPE_c$ by $C$</li></ul><h2 id=code-generation>Code Generation</h2><ul><li>Management of run-time resources</li><li>Correspondence between<ul><li>static (compile-time)</li><li>dynamic (run-time)</li></ul></li><li>Storage organization</li></ul><p>compiler is responsible for:</p><ul><li>Generating code</li><li>Orchestrating use of the data area</li></ul><p>two goals:</p><ul><li>correctness</li><li>speed</li></ul><h3 id=activations>Activations</h3><p>an invocation of procedure $P$ is an activation of $P$</p><p>the lifetime of an activation of $P$ is</p><ul><li>all the steps to execute $P$</li><li>including all the steps in procedures $P$ calls</li></ul><p>the lifetime of a variable $x$ is the portion of execution in which $x$ is defined</p><p>note</p><ul><li>lifetime is a dynamic (run-time) concept</li><li>scope is a static concept</li></ul><p>lifetimes of procedure activations are properly nested</p><p>activation lifetimes can be depicted as a tree</p><p>the activation tree depends on run-time behavior</p><p>since activations are properly nested, a stack can track currently active procedures</p><h4 id=activation-record-ar>Activation Record (AR)</h4><p>the information needed to manage one procedure activation is called an activation record (AR) or frame</p><p>if procedure $F$ calls $G$, then $G$&rsquo;s activation record contains a mix of info about $F$ and $G$, $G$&rsquo;s AR contains information needed to</p><ul><li>Complete execution of $G$</li><li>Resume execution of $F$</li></ul><p>The compiler must determine, at compile-time, the layout of activation records and generate code that correctly accesses locations in the activation record</p><h3 id=globals--heap>Globals & Heap</h3><p>Globals are assigned a fixed address once</p><ul><li>Variables with fixed address are &ldquo;statically allocated&rdquo;</li></ul><p>A value that outlives the procedure that creates it cannot be kept in the AR</p><p>Languages with dynamically allocated data use a Heap to store dynamic data</p><p>Spaces</p><p><img src=https://i.ibb.co/x1qwTLZ/image-20230314211257948.png loading=lazy alt=image-20230314211257948></p><ul><li><p>The code area contains object code</p><p>for many languages, fixed size and read only</p></li><li><p>The static area contains data (not code) with fixed addresses</p><p>fixed size, may be readable and writable</p></li><li><p>The stack contains an AR for each currently active procedure</p><p>each AR usually fixed size, contains locals</p></li><li><p>Heap contains all other data</p><p>heap is managed by malloc and free in C</p></li></ul><h3 id=alignment>Alignment</h3><p>Data is word aligned if it begins at a word boundary</p><p>Most machines have some alignment restrictions or performance penalties for poor alignment</p><h3 id=stack-machines>Stack Machines</h3><p>only storage is a stack</p><p>an instruction $r = F(a_1,&mldr;a_n)$ :</p><ul><li>Pops $n$ operands from the stack</li><li>Computes the operation $F$ using the operands</li><li>Pushes the result $r$ on the stack</li></ul><p>location of the operands/ result is not explicitly stated</p><ul><li>always the top of the stack</li></ul><p>In contrast to a register machine</p><ul><li>add instead of add r1, r2, r3</li><li>more compact programs</li></ul><p>There is an intermediate point between a pure stack machine and a pure register machine</p><p>An n-register stack machine</p><ul><li>conceptually, keep the top n locations of the pure stack machine&rsquo;s stack in registers</li></ul><p>consider a 1-register stack machine</p><ul><li>the register is called the accumulator</li></ul><ol><li>consider an expression $op(e_1,&mldr;,e_n)$, $e_1,&mldr;,e_n$ are subexpressions</li><li>for each $e_i$</li><li><ul><li>compute $e_i$</li><li>push result on the stack</li></ul></li><li>pop $n - 1$ values from the stack, compute $op$</li><li>store result in the accumulator</li></ol><h4 id=code-generation-1>code generation</h4><p>for each expression $e$ we generate MIPS code that</p><ul><li>computes the value of $e$ in $$a_0$</li><li>Preserves $$sp$ and the contents of the stack</li></ul><p>define a code generation function $cgen(e)$ whose result is the code generated for $e$</p><p>code generation can be written as <strong>a recursive-descent of the AST</strong></p><h3 id=variables>variables</h3><p>use a frame pointer</p><ul><li>always points to the return address on the stack</li><li>since it does not move it can be used to find the variables</li></ul><p>let $x_i$ be the $i-th$ formal parameter of the function for which code is being generated
$$
cgen(x_i) = lw\space $a_0\space 4*i($sp)
$$
The activation record must be designed together with the code generator</p><p>Using a stack machine for compiler is recommended.</p><p><strong>Production compilers</strong> do different things</p><ul><li>emphasis is on keeping values in registers</li><li>intermediate results are laid out in the AR, not pushed and popped from the stack</li></ul><h3 id=temporaries>temporaries</h3><p>the code generator must assign a fixed location in the AR for each temporary</p><p>let $NT(e)$ = count of temps needed to evaluate $e$</p><p>$NT(e_1+e_2)$</p><ul><li>needs at least as many temporaries as $NT(e_1)$</li><li>needs at least as many temporaries as $NT(e_2) + 1$</li></ul><p>for a function definition $f(x_1,&mldr;,x_n) = e$ then AR has $2+n+NT(e)$ elements</p><ul><li>return address</li><li>frame pointer</li><li>n arguments</li><li>$NT(e)$ locations for intermediate results</li></ul><p>code generation must know how many temporaries are in use at each point</p><p>add a new argument to code generation: the position of the next available temporary</p><p>the temporary area is used like a small, fixed-size stack</p><h3 id=object-layout>Object Layout</h3><p>OO implementation = Basic code generation + More stuff</p><p>OO slogan: If B is a subclass of A, then an object of class B can be used wherever an object of class A is expected</p><p>This means that code in class A works unmodified for an object of class B</p><p>Object are laid out in <strong>contiguous memory</strong></p><ul><li><p>Class tag is an integer</p><p>identifies class of the object</p></li><li><p>Object size is an integer</p><p>size of the object in words</p></li><li><p>Dispatch ptr is a pointer to a table of methods</p></li><li><p>attributes in subsequent slots</p></li></ul><p>Each attribute stored at a fixed offset in the object</p><p>Observation: Given a layout for class A, a layout for subclass B can be defined by extending the layout of A with additional slots for the additional attributes of B</p><h2 id=semantics>Semantics</h2><p>many ways to specify semantics:</p><p><strong>Operational Semantics</strong></p><ul><li>describes program evaluation via execution rules (on an abstract machine)</li><li>most useful for specifying implementations</li></ul><p><strong>Denotational Semantics</strong></p><ul><li>program&rsquo;s meaning is a mathematical function</li></ul><p><strong>Axiomatic Semantics</strong></p><ul><li>Program behavior described via logical formulae<ul><li>if execution begins in state satisfying X, then it ends in state satisfying Y</li><li>X, Y formulas</li></ul></li><li>Foundation of many program verification systems</li></ul><h3 id=operational-semantics>Operational Semantics</h3><p>Recall the typing judgment
$$
Context \vdash e: C
$$
in the given context, expression e has type C</p><p>We use something similar for evaluation
$$
Context \vdash e: v
$$
In the given context, expression e evaluates to value v</p><p>We track variables and their values with:</p><ul><li>An environment : where in memory a variable is</li><li>A store: what is in the memory</li></ul><p>A variable environment maps variables to locations</p><ul><li>keep track of which variables are in scope</li><li>tells us where those variables are</li></ul><p>$$
E = [a: I_1,b : I_2]
$$</p><p>A store maps memory locations to values
$$
S=[I_1\rightarrow5,I_2\rightarrow 7]
$$
$S^{&rsquo;}= S[12/I_1]$ defines a store $S^{&rsquo;}$ such that $S^{&rsquo;}(I_1)=12$ and $S^{&rsquo;} = S(I)$ if $I\ne I_1$</p><p>The evaluation judgement is
$$
so, E, S\vdash e: v, S^{&rsquo;}
$$</p><ul><li>Given so the current value of self</li><li>And E the current variable environment</li><li>And S the current store</li><li>If the evaluation of e terminates then</li><li>The value of e is v</li><li>And the new store is $S^{&rsquo;}$</li></ul><p>$$
E(id) = I_{id}\newline
S(I_{id}) = v \newline
&mdash;&mdash;&mdash;&mdash;-\newline
so,E,S\vdash id:v,S
$$</p><h2 id=intermediate-code>Intermediate Code</h2><p>A language between the source and the target</p><p>Provides an intermediate level of abstraction</p><ul><li>more details than the source</li><li>fewer details than the target</li></ul><p><strong>high-level assembly</strong></p><ul><li>uses register names, but has an unlimited number</li><li>uses control structures like assembly language</li><li>uses opcodes but some are higher level</li></ul><p><strong>common form of intermediate code</strong></p><p>each instruction is of the form
$$
x:= y\space op\space z
\newline
x:= op\space y
$$
$y$ and $z$ are registers or constants</p><p>similar to assembly code generation</p><p>but use any number of IL registers to hold intermediate results</p><h2 id=optimization>Optimization</h2><p>optimization is out <strong>last</strong> compiler phase</p><p>most <strong>complexity</strong> in modern compilers is in the optimizer</p><p>seeks to improve a program&rsquo;s resource utilization</p><ul><li>execution time (most often)</li><li>code size</li><li>network messages sent, etc.</li></ul><p>when：</p><ul><li><p>On AST</p><ul><li>Pro: machine independent</li><li>Con: too high level</li></ul></li><li><p>On assembly language</p><ul><li><p>Pro: Exposes optimization opportunities</p></li><li><p>Con:</p><p>Machine dependent</p><p>Must reimplement optimizations when retargeting</p></li></ul></li><li><p>On an intermediate language</p><ul><li><p>Pro:</p><p>Machine independent</p><p>Exposes optimization opportunities</p></li></ul></li></ul><h3 id=basic-block>Basic Block</h3><p>A basic block is a maximal sequence of instructions with:</p><ul><li>no labels (except at the first instruction)</li><li>no jumps (except at the last instruction)</li></ul><p>idea</p><ul><li>cannot jump into a basic block (except at beginning)</li><li>cannot jump out of a basic block (except at end)</li><li>a basic block is a single-entry, single-exit, straight-line code segment</li></ul><h3 id=control-flow-graph>control-flow graph</h3><p>a control-flow-graph is a directed graph with</p><ul><li>basic blocks as nodes</li><li>an edge from block A to block B if the execution can pass form the last instruction in A to the first instruction in B</li></ul><p>the body of a method (or procedure) can be represented as a control-flow graph</p><h3 id=granularity>Granularity</h3><ol><li><p>local optimizations</p><p>apply to a basic block in isolation</p></li><li><p>Global optimizations</p><p>apply to a control-flow graph (method body) in isolation</p></li><li><p>Inter-procedural optimizations</p><p>apply across method boundaries</p></li></ol><p>most compilers do 1. many do 2. few do 3.</p><p>In practice, often a conscious decision is made not to implement the fanciest optimization known</p><ul><li>some optimizations are hard to implement</li><li>some optimizations are costly in compilation time</li><li>some optimizations have low payoff</li><li>many fancy optimizations are all three!</li></ul><h3 id=local-optimization>Local Optimization</h3><p>optimize one basic block</p><p>no need to analyze the whole procedure body</p><ul><li><p>some statement can be deleted</p><p>$x:= x + 0$</p><p>$x:= x*1$</p></li><li><p>some statements can be simplified</p><p>$x:=x*0$ to $x:=0$</p><p>$y:= y**2$ to $y:=y*y$</p><p>$x:=x*8$ to $x:=x&#171;3$</p><p>$x:=x*15$ to $t:=x &#171; 4; x:=t-x$</p></li><li><p>Operations on constants can be computed at compile time</p><ul><li>if there is a statement $x:=y\space op\space z$</li><li>and $y$ and $z$ are constants</li><li>then $y$ op $z$ can be computed at compile time</li></ul></li><li><p>constant folding can be dangerous</p><p>in cross-compiler</p></li><li><p>Eliminate unreachable blocks</p></li></ul><p>some optimizations are simplified if each register occurs only once on the left-hand side of an assignment</p><p><strong>common subexpression elimination</strong></p><p>if</p><ul><li>basic block is in single assignment form</li><li>a definition $x:=$ is the first use of $x$ in a block</li></ul><p>then</p><ul><li>When two assignments have the same rhs, they compute the same value</li></ul><p><strong>copy propagation</strong></p><p>if $w:= x$ appears in a block, replace subsequent uses of $w$ with uses of $x$</p><p><strong>dead elimination</strong></p><p>if</p><p>$w:=rhs$ appears in a basic block</p><p>$w$ does not appear anywhere else in the program</p><p>then</p><p>the statement $w:=rhs$ is dead and can be eliminated</p><p>typically optimizations interact: performing one optimization enables another</p><p>optimizing compilers repeat optimizations until no improvement is possible</p><h4 id=peephole-optimization>Peephole optimization</h4><p>optimizations can be directly applied to assembly code</p><p>Peephole optimization is effective for improving assembly code</p><p>the &ldquo;peephole&rdquo; is a short sequence of (usually contiguous) instructions</p><p>the optimizer replaces the sequence with another equivalent one (but faster)</p><h3 id=global-optimization>Global Optimization</h3><p>Global optimization tasks share several traits:</p><ul><li>The optimization depends on knowing a property X at a particular point in program execution</li><li>Proving X at any point requires knowledge of the entire program</li></ul><h4 id=dataflow-analysis>Dataflow Analysis</h4><p>To replace a use of x by a constant k we must know: on every path to the use of x, the last assignment to x is $x:=k$</p><p>Checking the condition requires global dataflow analysis: an analysis of the entire control-flow graph</p></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Jun 06, 2023 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/software-architecturenotes/><div class=article-details><h2 class=article-title>【Software Architecture】Notes</h2></div></a></article><article><a href=/p/computer-architecturenotes/><div class=article-details><h2 class=article-title>【Computer Architecture】Notes</h2></div></a></article><article><a href=/p/computer-networknotes/><div class=article-details><h2 class=article-title>【Computer Network】Notes</h2></div></a></article><article><a href=/p/computer-visionnotes/><div class=article-details><h2 class=article-title>【Computer Vision】Notes</h2></div></a></article><article><a href=/p/stanford-reinforcement-learningnotes/><div class=article-details><h2 class=article-title>【Stanford Reinforcement Learning】Notes</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>