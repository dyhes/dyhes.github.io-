<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="OverView 软件价值观 行为价值:让程序完成指定的功能 大多数程序员认为这是主要工作——完成功能、发现并修正bug 架构价值:让程序保持易于修改 容易被忽视，但这种价值更符合“软件”的存在逻辑 软件之所以存在并发展，就是因为它比硬件“软” 用户的需求在变、股东的方向在变 历史 在20世纪90年代，有一个协调一致的努力来定义和编纂该学科的基本方面，研究工作集中在体系结构风格(模式)、体系结构描述语言、体系结构文档和形式化方法上。 卡内基梅隆大学的Mary Shaw和David Garlan在1996年写了一本名为《软件架构:新兴学科的视角》的书，这本书促进了诸如组件、连接器和风格等软件架构概念。 定义 Wikipedia\nSoftware architecture is the set of structures required for analyzing a software system and the field of creating such structures and systems. Each structure consists of software elements, the relationships between them, as well as the properties of both the elements and the relationships. IEEE 1471-2000 Software architecture is the fundamental organization of a system, embodied in its components, their relationships to each other and the environment, and the principles governing its design and evolution. Programming Paradigms 结构化程序设计 (Structured Programming) 面向对象程序设计 (Object-Oriented Programming) 函数式程序设计 (Functional Programming) 结构化程序设计 Dijkstra是发现程序设计这个学科、并将其发展成一门科学的人之一 对于’不管多简单的程序，只要程序员稍稍忽视一点细节，程序就会看似正确，却以令人诧异的方式出错‘的问题，Dijkstra 的方案：程序的形式化证明\n"><title>【Software Architecture】Notes</title>
<link rel=canonical href=https://dyhes.github.io/p/software-architecturenotes/><link rel=stylesheet href=/scss/style.min.6aa4d43a5cae1c51ef34b3f851ae7421f4b2f2d13827e2d975acbeb4f13c8710.css><meta property='og:title' content="【Software Architecture】Notes"><meta property='og:description' content="OverView 软件价值观 行为价值:让程序完成指定的功能 大多数程序员认为这是主要工作——完成功能、发现并修正bug 架构价值:让程序保持易于修改 容易被忽视，但这种价值更符合“软件”的存在逻辑 软件之所以存在并发展，就是因为它比硬件“软” 用户的需求在变、股东的方向在变 历史 在20世纪90年代，有一个协调一致的努力来定义和编纂该学科的基本方面，研究工作集中在体系结构风格(模式)、体系结构描述语言、体系结构文档和形式化方法上。 卡内基梅隆大学的Mary Shaw和David Garlan在1996年写了一本名为《软件架构:新兴学科的视角》的书，这本书促进了诸如组件、连接器和风格等软件架构概念。 定义 Wikipedia\nSoftware architecture is the set of structures required for analyzing a software system and the field of creating such structures and systems. Each structure consists of software elements, the relationships between them, as well as the properties of both the elements and the relationships. IEEE 1471-2000 Software architecture is the fundamental organization of a system, embodied in its components, their relationships to each other and the environment, and the principles governing its design and evolution. Programming Paradigms 结构化程序设计 (Structured Programming) 面向对象程序设计 (Object-Oriented Programming) 函数式程序设计 (Functional Programming) 结构化程序设计 Dijkstra是发现程序设计这个学科、并将其发展成一门科学的人之一 对于’不管多简单的程序，只要程序员稍稍忽视一点细节，程序就会看似正确，却以令人诧异的方式出错‘的问题，Dijkstra 的方案：程序的形式化证明\n"><meta property='og:url' content='https://dyhes.github.io/p/software-architecturenotes/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2025-01-13T00:00:00+00:00'><meta property='article:modified_time' content='2025-01-13T00:00:00+00:00'><meta name=twitter:title content="【Software Architecture】Notes"><meta name=twitter:description content="OverView 软件价值观 行为价值:让程序完成指定的功能 大多数程序员认为这是主要工作——完成功能、发现并修正bug 架构价值:让程序保持易于修改 容易被忽视，但这种价值更符合“软件”的存在逻辑 软件之所以存在并发展，就是因为它比硬件“软” 用户的需求在变、股东的方向在变 历史 在20世纪90年代，有一个协调一致的努力来定义和编纂该学科的基本方面，研究工作集中在体系结构风格(模式)、体系结构描述语言、体系结构文档和形式化方法上。 卡内基梅隆大学的Mary Shaw和David Garlan在1996年写了一本名为《软件架构:新兴学科的视角》的书，这本书促进了诸如组件、连接器和风格等软件架构概念。 定义 Wikipedia\nSoftware architecture is the set of structures required for analyzing a software system and the field of creating such structures and systems. Each structure consists of software elements, the relationships between them, as well as the properties of both the elements and the relationships. IEEE 1471-2000 Software architecture is the fundamental organization of a system, embodied in its components, their relationships to each other and the environment, and the principles governing its design and evolution. Programming Paradigms 结构化程序设计 (Structured Programming) 面向对象程序设计 (Object-Oriented Programming) 函数式程序设计 (Functional Programming) 结构化程序设计 Dijkstra是发现程序设计这个学科、并将其发展成一门科学的人之一 对于’不管多简单的程序，只要程序员稍稍忽视一点细节，程序就会看似正确，却以令人诧异的方式出错‘的问题，Dijkstra 的方案：程序的形式化证明\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu17834253352308399148.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#overview>OverView</a><ol><li><a href=#软件价值观>软件价值观</a></li><li><a href=#历史>历史</a></li><li><a href=#定义>定义</a></li></ol></li><li><a href=#programming-paradigms>Programming Paradigms</a><ol><li><a href=#结构化程序设计>结构化程序设计</a></li><li><a href=#面向对象程序设计>面向对象程序设计</a></li><li><a href=#函数式程序设计>函数式程序设计</a></li><li><a href=#总结>总结</a></li></ol></li><li><a href=#principals>Principals</a><ol><li><a href=#设计原则>设计原则</a></li><li><a href=#组件原则>组件原则</a></li></ol></li><li><a href=#组件风格>组件风格</a></li><li><a href=#管道过滤器风格>管道过滤器风格</a><ol><li><a href=#优势><strong>优势</strong></a></li><li><a href=#缺点><strong>缺点</strong></a></li><li><a href=#总结-1><strong>总结</strong></a></li></ol></li><li><a href=#分层风格>分层风格</a><ol><li><a href=#优势-1><strong>优势</strong></a></li><li><a href=#总结-2>总结</a></li></ol></li><li><a href=#事件驱动风格>事件驱动风格</a></li><li><a href=#共享数据风格>共享数据风格</a><ol><li><a href=#黑板风格>黑板风格</a></li><li><a href=#总结-3>总结</a></li></ol></li><li><a href=#客户端服务器风格>客户端服务器风格</a><ol><li><a href=#总结-4>总结</a></li></ol></li><li><a href=#端到端风格>端到端风格</a></li><li><a href=#面向服务风格>面向服务风格</a><ol><li><a href=#对比>对比</a></li><li><a href=#近亲>近亲</a></li><li><a href=#组成>组成</a></li></ol></li><li><a href=#无共享风格>无共享风格</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/star/ style=background-color:#2e317c;color:>一天星</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/software-architecturenotes/>【Software Architecture】Notes</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jan 13, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><h2 id=overview>OverView</h2><h3 id=软件价值观>软件价值观</h3><ul><li>行为价值:让程序完成指定的功能<ul><li>大多数程序员认为这是主要工作——完成功能、发现并修正bug</li></ul></li><li>架构价值:让程序保持<strong>易于修改</strong><ul><li>容易被忽视，但这种价值更符合“软件”的存在逻辑</li><li>软件之所以存在并发展，就是因为它比硬件“软”</li><li>用户的需求在变、股东的方向在变</li></ul></li></ul><h3 id=历史>历史</h3><ul><li>在20世纪90年代，有一个协调一致的努力来定义和编纂该学科的基本方面，研究工作集中在体系结构风格(模式)、体系结构描述语言、体系结构文档和形式化方法上。</li><li>卡内基梅隆大学的Mary Shaw和David Garlan在1996年写了一本名为《软件架构:新兴学科的视角》的书，这本书促进了诸如组件、连接器和风格等软件架构概念。</li></ul><h3 id=定义>定义</h3><p>Wikipedia</p><ul><li>Software architecture is the set of structures required for analyzing a software system and the field of creating such structures and systems.</li><li>Each structure consists of software <strong>elements</strong>, the <strong>relationships</strong> between them, as well as the <strong>properties</strong> of both the elements and the relationships.
IEEE 1471-2000
Software architecture is the fundamental organization of a system, embodied in its <strong>components</strong>, their <strong>relationships</strong> to each other and the environment, and the <strong>principles</strong> governing its design and evolution.</li></ul><h2 id=programming-paradigms>Programming Paradigms</h2><ul><li>结构化程序设计 (Structured Programming)</li><li>面向对象程序设计 (Object-Oriented Programming)</li><li>函数式程序设计 (Functional Programming)</li></ul><h3 id=结构化程序设计>结构化程序设计</h3><p>Dijkstra是发现程序设计这个学科、并将其发展成一门科学的人之一
对于’不管多简单的程序，只要程序员稍稍忽视一点细节，程序就会看似正确，却以令人诧异的方式出错‘的问题，Dijkstra 的方案：程序的<strong>形式化证明</strong></p><ul><li>用欧式几何的思路：公理、引理、定理&mldr;&mldr;</li><li>程序员可以用可证明正确的结构，搭建出更大的程序</li><li>顺序、分支、循环、调用、递归&mldr;&mldr; 结构化程序设计由此诞生了</li></ul><ul><li>结构化程序设计取得了巨大的成功<ul><li>因为它使得我们能够将任务层层分解（直到无穷）</li></ul></li><li>程序的形式化证明至今未能广泛应用（太累了！）<ul><li>取而代之的是更“科学”的方法</li></ul></li></ul><h3 id=面向对象程序设计>面向对象程序设计</h3><p>面向对象</p><ul><li><strong>数据</strong>与<strong>函数</strong>的组合</li><li>封装、继承、多态
对于软件架构师来说，面向对象是一种通过使用多态获得的，对系统中每个源代码依赖的绝对控制能力</li><li>允许软件架构师创建插件架构，让高级策略模块独立于低级细节模块</li><li>低级细节被下放到插件模块中，可以独立于高级策略模块进行部署和开发</li></ul><h3 id=函数式程序设计>函数式程序设计</h3><ul><li>函数式程序设计是<strong>以函数为核心</strong>的程序设计范式</li><li>所有的并发问题都是由于变量(内存里的值)可变引起的<ul><li>函数式程序设计中，变量“不变”</li><li>将尽量多的功能实现在不可变组件中，尽量少的实现在可变组件中</li></ul></li></ul><h3 id=总结>总结</h3><ul><li>结构化程序设计<ul><li>剥夺了程序员使用<strong>跳转语句</strong>的自由，赋予了软件<strong>模块化</strong>的能力</li></ul></li><li>面向对象程序设计<ul><li>剥夺了程序员使用<strong>函数指针</strong>的自由，赋予了软件<strong>插件化</strong>的能力</li></ul></li><li>函数式程序设计<ul><li>剥夺了程序员使用<strong>赋值语句</strong>的自由，赋予了软件<strong>并行化</strong>的能力</li></ul></li></ul><h2 id=principals>Principals</h2><ul><li>设计原则<ul><li>如何将函数和数据组织为类</li><li>将砖拼装为房间</li></ul></li><li>组件原则<ul><li>如何将类组织为组件和软件</li><li>将房间拼装为大楼</li></ul></li></ul><h3 id=设计原则>设计原则</h3><ul><li>Single Responsibility Principle<ul><li>一个类应该只有一个引起它变化的原因。这意味着一个类应该只负责一个功能或职责，并且所有行为都与该职责紧密相关。</li></ul></li><li>Open-Closed Principle<ul><li>软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。</li></ul></li><li>Liskov Substitution Principle<ul><li>子类对象应该能够替换其基类对象，并且不破坏程序的正确性。这个原则强调了继承关系中子类对基类行为的一致性。</li></ul></li><li>Interface Segregation Principle<ul><li>可能被不同模块调用的函数，应抽象为不同的接口</li></ul></li><li>Dependency Inversion Principle<ul><li>高层模块不应该依赖于低层模块，两者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。</li></ul></li></ul><h3 id=组件原则>组件原则</h3><ul><li>组件聚合原则：哪些类组织到哪个组件？<ul><li>Reuse/Release Equivalence Principle<ul><li>重用的粒度，就是发布的粒度</li></ul></li><li>Common Closure Principle<ul><li>把那些会因为相同原因而同时修改的类组成一个组件，把那些会因为不同原因而分别修改的类组分隔为不同组件。</li><li>组件层次的单一责任原则SRP。</li><li>可维护 > 可重用。</li><li>一次修改最好集中在一个组件，不希望横跨多个组件。</li><li>修改一个组件，不相关的组件无需重新编译部署。</li></ul></li><li>Common Reuse Principle<ul><li>不要强迫组件的用户依赖它不需要的东西(类、接口等)</li><li>组件层次的接口隔离原则ISP</li></ul></li></ul></li><li>组件耦合原则：组件之间如何交互？<ul><li>Acyclic Dependencies Principle<ul><li>组件依赖图中不能有环</li><li>如何消除环？<ul><li>使用依赖反转原则DIP</li><li>加入新组件管理权限</li><li>系统不是被自顶向下设计出来的，而是随着系统增长被演化出来的</li></ul></li></ul></li></ul></li><li>Stable Dependencies Principle<ul><li>依赖方向应从不稳定到稳定</li><li>不应让不稳定的组件被难于修改的组件依赖</li><li>不稳定性 I=Degree_out/(Degree_out + Degree_in)</li><li>依赖方向为𝐼值降序方向</li></ul></li><li>Stable Abstractions Principle<ul><li>组件的稳定性应与它的抽象程度对应</li><li>越抽象越稳定，越稳定越抽象</li><li>依赖方向应该为具体依赖抽象</li><li>抽象度 A=N_abstract_class/N_class</li><li>组件应尽量接近“主序线”: 𝐷𝑖𝑠𝑡𝑎𝑛𝑐𝑒= |𝐴+𝐼-1|
<strong>组件历史</strong></li></ul></li><li>最初，程序所在的位置是固定的，后来，应用越来越大，编译时间越来越长，函数库诞生了。</li><li>由于位置是固定的，应用被限制在了函数库之前的位置，一旦超出预留的大小，应用程序就需要被切分。</li><li>人们终于意识到，程序需要能够重定位。如何实现程序的重定位？<ul><li>加载顺序</li><li>动态链接</li></ul></li><li>可单独编译、可独立发布、可动态加载、可动态链接的软件模块 ——组件</li></ul><h2 id=组件风格>组件风格</h2><p>组件（Component）</p><ul><li>一组函数和数据的封装</li><li>组件间通过接口沟通</li><li>组件可被同样接口的组件替换</li><li>组件被充分测试，足够鲁棒</li><li>组件有足够的文档说明
组件风格</li><li>组件风格关注可复用的组件。</li><li>实际制造满足需要的组件非常困难。</li><li>组件模型为制造组件提供模板规范。
组件模型</li><li>Enterprise JavaBeans (EJB) 模型</li><li>Component Object Model (COM) 模型</li><li>.NET模型</li><li>X-MAN组件模型</li><li>Common Object Request Broker Architecture (CORBA) 组件模型</li></ul><h2 id=管道过滤器风格>管道过滤器风格</h2><ul><li>过滤器<ul><li>每个组件都有其输入和输出</li><li>组件的处理过程就是根据输入产生输出</li></ul></li><li>管道<ul><li>连接两个组件，将一个组件的输出变成另一个组件的输入</li></ul></li><li>过滤器通过管道连接为<strong>有向无环图</strong>，形成复杂功能</li><li>对比：<ul><li>组件风格关注组件提供/需要的接口</li><li>管道-过滤器风格强调<strong>数据流</strong>的衔接</li></ul></li></ul><h3 id=优势><strong>优势</strong></h3><ul><li>弱耦合性：各个过滤器相互独立，设计者可以将整个系统的输入、输出特性理解为各个过滤器功能的简单合成。</li><li>易于重用：任意两个过滤器只要相互间传输的数据格式一致，就可以连接在一起。</li><li>易于维护扩展：新过滤器可以很容易加入到系统中，旧的过滤器可以很容易被新的过滤器替代。</li><li>易于分析测试：每个过滤器可以独立测试。</li><li>天然并发性：每个过滤器都可以独立运行，形成流水线pipeline。</li></ul><h3 id=缺点><strong>缺点</strong></h3><ul><li>交互性差：由于过滤器的传输特性，管道过滤器模式通常不适合于交互性很强的应用。尤其是在系统需要逐步显示数据流变化的过程时，因为增量显示和过滤器的输出数据差距太大。</li><li>维持通信困难：维持两个相对独立但存在某种关系的数据流之间的通信可能很困难。</li><li>通信效率低：设计者也需要在数据传输时被迫使用底层公共命名，导致过滤器必须对输入、输出管道中的数据进行解析或反解析的额外工作。</li></ul><h3 id=总结-1><strong>总结</strong></h3><ul><li>管道-过滤器风格关注可连接的组件</li></ul><ul><li>将组件功能抽象为从输入数据到输出数据的过滤过程</li></ul><ul><li>通过管道，连接过滤器，形成复杂的数据处理功能</li><li>天然对分布式并发特性具有良好适应</li><li>管道中的传输过程有待改进</li></ul><h2 id=分层风格>分层风格</h2><h3 id=优势-1><strong>优势</strong></h3><ul><li>分层符合人类“分而治之”的思维方式。<ul><li>结构化程序设计之所以能够取得巨大的成功，正是因为它使得我们能够将任务层层分解。</li></ul></li><li>耦合性低。</li><li>重用性高。</li><li>可维护性高。</li><li>无环依赖原则（Acyclic Dependencies Principle，ADP）<ul><li>组件依赖图中不能有环。</li><li>有向无环图一定能分层。</li></ul></li></ul><h3 id=总结-2>总结</h3><ul><li>分层风格关注组件间的<strong>偏序关系</strong></li></ul><ul><li>将系统功能层层分解，降低耦合性，提升重用性</li></ul><ul><li>最常见的分层风格是三层架构</li><li>层与层之间隔离有利于快速部署</li><li>层与层之间协同有利于性能效率</li></ul><h2 id=事件驱动风格>事件驱动风格</h2><ul><li>以事件衔接程序之间的数据流</li><li>程序产生事件，触发其他程序的功能</li><li>事件驱动风格可以认为是广义的管道-过滤器风格</li><li>优缺点与管道-过滤器风格类似</li><li>事件驱动风格的程序框架通常是提供事件等待/触发机制的中间件</li></ul><h2 id=共享数据风格>共享数据风格</h2><h3 id=黑板风格>黑板风格</h3><ul><li>黑板模块：全局存储空间</li><li>知识源模块：处理知识、更新黑板</li><li>控制模块：调度可用的知识源模块</li></ul><h3 id=总结-3>总结</h3><ul><li>黑板风格：与其移动数据，不如共享数据！</li><li>数据中心风格：与其移动数据，不如移动程序！</li></ul><h2 id=客户端服务器风格>客户端服务器风格</h2><ul><li>服务器：拥有资源，提供服务</li><li>客户端：建立会话，提出请求</li></ul><h3 id=总结-4>总结</h3><ul><li>天然的两层分层风格<ul><li>如何将三层风格变为两层风格？根据通信量切分</li></ul></li><li>问题：随着资源规模和请求吞吐量需求增大，服务器成为瓶颈</li><li>解决方案<ul><li>端到端风格</li><li>端-边-云架构</li></ul></li></ul><h2 id=端到端风格>端到端风格</h2><p>Peer-to-Peer, P2P</p><ul><li>去中心：所有参与者在网络中是平等的</li><li>每个参与者都提供一部分资源（计算、存储、带宽等）</li><li>有效解决了客户端-服务器风格中，服务器的资源瓶颈
<strong>核心优势</strong></li><li>全局内容发现</li><li>高效的内容索引</li></ul><p>端到端架构将参与者重新组织为逻辑网络</p><ul><li>非结构化网络<ul><li>Gnutella、Gossip、Kazaa&mldr;&mldr;</li><li>易于组织，支持参与者随时加入离开</li><li>难以发现内容</li></ul></li><li>结构化网络<ul><li>分布式哈希表DHT</li><li>每个参与者、内容均与键值联系</li><li>易于全局内容发现，但存在均衡问题</li></ul></li></ul><h2 id=面向服务风格>面向服务风格</h2><ul><li>将软件分解为多个独立的服务</li><li>服务：独立的功能单元，可通过通信协议与之进行远程沟通<ul><li>代表可重复的业务活动</li><li>具有相对完整的功能</li><li>对用户是黑盒，用户无需关心服务的内部实现</li><li>可以调用其他服务完成功能</li></ul></li></ul><h3 id=对比>对比</h3><ul><li>与组件风格对比<ul><li>在组件风格中，通常支持多个组件在同一个进程中</li><li>服务更强调独立性，通信协议均为网络协议（支持跨进程通信）</li></ul></li><li>与管道-过滤器风格对比<ul><li>过滤器之间通过管道传递消息，不关心消息被用来做什么了</li><li>服务接受的是请求，并须要针对请求给出答复</li><li>与事件驱动风格也有类似的区别</li></ul></li><li>与分层风格对比<ul><li>只要服务与服务之间的“调用”关系不存在“递归”，就也属于分层风格</li><li>万一服务之间有递归呢？</li></ul></li><li>与客户端-服务器风格对比<ul><li>客户端-服务器风格中，通常服务器是整个系统中的单个中心</li><li>面向服务风格中，服务可以有很多</li></ul></li></ul><h3 id=近亲>近亲</h3><ul><li>糅合（Mashup）<ul><li>将两种以上使用公共或者私有数据库的Web应用加在一起，形成一个整合应用</li></ul></li><li>软件即服务（SaaS，Software as a Service）<ul><li>让用户能够通过互联网连接来使用基于云的应用程序</li></ul></li><li>云计算（Cloud Computing）<ul><li>将来自用户的任务请求分解成数个小程序，利用网络“云”上多部服务器的资源进行并行处理，得到结果并返回给用户</li></ul></li></ul><h3 id=组成>组成</h3><ul><li>服务提供者<ul><li>向服务中间人注册自己提供的服务，答复服务请求者的请求</li></ul></li><li>服务请求者<ul><li>要求服务中间人查找所需服务，向服务提供者提出请求</li></ul></li><li>服务中间人（服务注册、服务检索）<ul><li>注册服务提供者，给服务请求者反馈服务提供者信息</li><li>可以分为公有中间人、私有中间人</li></ul></li></ul><h2 id=无共享风格>无共享风格</h2><p>Shared-Nothing Architecture</p><ul><li>分布式系统风格</li><li>每个更新操作只由集群中的一个结点来完成</li><li>与Shared Everything<strong>相对</strong>，旨在消除数据竞争
数据库两大类应用</li><li>联机事务处理（OLTP，On-Line Transaction Processing）</li><li>联机分析处理（OLAP，On-Line Analytical Processing）
新兴数据库</li><li>特点<ul><li>容量需求大</li><li>数据增加多</li><li>数据更新少</li><li>查询效率尽量快</li></ul></li><li>数据仓库（Data Warehouse）</li><li>数据湖（Data Lake）</li></ul></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Jan 13, 2025 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/computer-architecturenotes/><div class=article-details><h2 class=article-title>【Computer Architecture】Notes</h2></div></a></article><article><a href=/p/computer-networknotes/><div class=article-details><h2 class=article-title>【Computer Network】Notes</h2></div></a></article><article><a href=/p/computer-visionnotes/><div class=article-details><h2 class=article-title>【Computer Vision】Notes</h2></div></a></article><article><a href=/p/stanford-compilersnotes/><div class=article-details><h2 class=article-title>【Stanford Compilers】Notes</h2></div></a></article><article><a href=/p/stanford-reinforcement-learningnotes/><div class=article-details><h2 class=article-title>【Stanford Reinforcement Learning】Notes</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>