<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Hint chapter 1 存储程序概念\nchapter 2 重点IEEE754\nchapter 3 w9 c1\n3.4.10.13.14.18.22\n拓展操作码-设计\nEA计算\n一定要画出指令结构图\n标清B、H、Q\n位数写够\nchapter 4 一位定点数的乘除法\nw12 c3\n6.8.10 (2) (4) .12\n均n次移位\n补乘 辅助位$y_{n+1}-y_{n}$\n原除 变补\nchapter 5 主存储器容量扩展-设计\ncache计算\nw10 12:13\n例题\nw14 c1\n10.13.14.16.17.18. 25\n画图标注！\nRom不连 WE非！\n芯片规格、译码器规格、高低有效电平\ncache\n主存：区号+组号+块号+块内地址\n组相联映象\n主存和Cache按同样大小划分成块， 还按同样大小划分成组。\n从主存的组到Cache的组之间采用直接映象方式。 在两个对应的组内部采用全相联映象（1对1）方式。\nchapter 6 微指令编码法-设计\n6,7,9,12,13,20\n参数计算公式\n微命令设计\n结构和命令\n结构画出来、阐述\n命令一条条写出来\nchapter 8、9 数字磁记录方式-画图\n2.3.5\n"><title>【计算机组成原理】笔记</title>
<link rel=canonical href=https://dyhes.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/><link rel=stylesheet href=/scss/style.min.6aa4d43a5cae1c51ef34b3f851ae7421f4b2f2d13827e2d975acbeb4f13c8710.css><meta property='og:title' content="【计算机组成原理】笔记"><meta property='og:description' content="Hint chapter 1 存储程序概念\nchapter 2 重点IEEE754\nchapter 3 w9 c1\n3.4.10.13.14.18.22\n拓展操作码-设计\nEA计算\n一定要画出指令结构图\n标清B、H、Q\n位数写够\nchapter 4 一位定点数的乘除法\nw12 c3\n6.8.10 (2) (4) .12\n均n次移位\n补乘 辅助位$y_{n+1}-y_{n}$\n原除 变补\nchapter 5 主存储器容量扩展-设计\ncache计算\nw10 12:13\n例题\nw14 c1\n10.13.14.16.17.18. 25\n画图标注！\nRom不连 WE非！\n芯片规格、译码器规格、高低有效电平\ncache\n主存：区号+组号+块号+块内地址\n组相联映象\n主存和Cache按同样大小划分成块， 还按同样大小划分成组。\n从主存的组到Cache的组之间采用直接映象方式。 在两个对应的组内部采用全相联映象（1对1）方式。\nchapter 6 微指令编码法-设计\n6,7,9,12,13,20\n参数计算公式\n微命令设计\n结构和命令\n结构画出来、阐述\n命令一条条写出来\nchapter 8、9 数字磁记录方式-画图\n2.3.5\n"><meta property='og:url' content='https://dyhes.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2023-06-06T00:00:00+00:00'><meta property='article:modified_time' content='2023-06-06T00:00:00+00:00'><meta name=twitter:title content="【计算机组成原理】笔记"><meta name=twitter:description content="Hint chapter 1 存储程序概念\nchapter 2 重点IEEE754\nchapter 3 w9 c1\n3.4.10.13.14.18.22\n拓展操作码-设计\nEA计算\n一定要画出指令结构图\n标清B、H、Q\n位数写够\nchapter 4 一位定点数的乘除法\nw12 c3\n6.8.10 (2) (4) .12\n均n次移位\n补乘 辅助位$y_{n+1}-y_{n}$\n原除 变补\nchapter 5 主存储器容量扩展-设计\ncache计算\nw10 12:13\n例题\nw14 c1\n10.13.14.16.17.18. 25\n画图标注！\nRom不连 WE非！\n芯片规格、译码器规格、高低有效电平\ncache\n主存：区号+组号+块号+块内地址\n组相联映象\n主存和Cache按同样大小划分成块， 还按同样大小划分成组。\n从主存的组到Cache的组之间采用直接映象方式。 在两个对应的组内部采用全相联映象（1对1）方式。\nchapter 6 微指令编码法-设计\n6,7,9,12,13,20\n参数计算公式\n微命令设计\n结构和命令\n结构画出来、阐述\n命令一条条写出来\nchapter 8、9 数字磁记录方式-画图\n2.3.5\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu17834253352308399148.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#hint>Hint</a><ol><li><a href=#chapter-1>chapter 1</a></li><li><a href=#chapter-2>chapter 2</a></li><li><a href=#chapter-3>chapter 3</a></li><li><a href=#chapter-4>chapter 4</a></li><li><a href=#chapter-5>chapter 5</a></li><li><a href=#chapter-6>chapter 6</a></li><li><a href=#chapter-89>chapter 8、9</a></li></ol></li><li><a href=#chapter-2-数据的机器层次表示>Chapter 2 数据的机器层次表示</a><ol><li><a href=#浮点表示法>浮点表示法</a><ol><li><a href=#移码>移码</a></li><li><a href=#ieee754>IEEE754</a></li></ol></li><li><a href=#非数值数据>非数值数据</a></li></ol></li><li><a href=#chapter-3-指令系统>Chapter 3 指令系统</a><ol><li><a href=#指令格式>指令格式</a><ol><li><a href=#操作码>操作码</a></li></ol></li><li><a href=#寻址技术>寻址技术</a><ol><li><a href=#编址方式>编址方式</a></li><li><a href=#数据寻址>数据寻址</a></li></ol></li><li><a href=#堆栈>堆栈</a></li><li><a href=#指令类型>指令类型</a></li><li><a href=#发展>发展</a></li></ol></li><li><a href=#chapter-4-数值的机器运算>Chapter 4 数值的机器运算</a><ol><li><a href=#加法器-不要求>加法器 （不要求？）</a><ol><li><a href=#并行快速进位>并行快速进位</a></li><li><a href=#分组并行进位>分组并行进位</a></li></ol></li><li><a href=#定点乘法>定点乘法</a><ol><li><a href=#原码一位乘法>原码一位乘法</a></li><li><a href=#补码一位乘法>补码一位乘法</a></li></ol></li><li><a href=#定点除法>定点除法</a><ol><li><a href=#原码加减交替法>原码加减交替法</a></li><li><a href=#补码加减交替法>补码加减交替法</a></li></ol></li><li><a href=#规格化浮点数运算>规格化浮点数运算</a></li></ol></li><li><a href=#chapter-5-存储系统>Chapter 5 存储系统</a><ol><li><a href=#存储器>存储器</a></li><li><a href=#主存>主存</a><ol><li><a href=#技术指标>技术指标</a></li></ol></li><li><a href=#半导体随机存储器和只读存储器>半导体随机存储器和只读存储器</a></li><li><a href=#ram>RAM</a><ol><li><a href=#dram>DRAM</a></li><li><a href=#ram芯片分析>RAM芯片分析</a></li></ol></li><li><a href=#rom>ROM</a></li><li><a href=#主存储器的连接与控制>主存储器的连接与控制</a><ol><li><a href=#主存容量的扩展>主存容量的扩展</a></li><li><a href=#地址分配和片选>地址分配和片选</a></li><li><a href=#主存与cpu连接>主存与CPU连接</a></li></ol></li><li><a href=#高速缓冲存储器>高速缓冲存储器</a></li></ol></li><li><a href=#chapter-6-cpu>Chapter 6 CPU</a><ol><li><a href=#功能和组成>功能和组成</a><ol><li><a href=#主要寄存器>主要寄存器</a></li><li><a href=#功能>功能</a></li><li><a href=#主要技术参数>主要技术参数</a></li></ol></li><li><a href=#控制器的组成和实现>控制器的组成和实现</a></li><li><a href=#时序系统与控制方式>时序系统与控制方式</a><ol><li><a href=#时序系统>时序系统</a></li><li><a href=#控制方式>控制方式</a></li><li><a href=#指令执行过程>指令执行过程</a></li><li><a href=#指令的微操作序列>指令的微操作序列</a></li></ol></li><li><a href=#微程序控制原理>微程序控制原理</a><ol><li><a href=#微指令编码法>微指令编码法</a></li><li><a href=#微程序控制器的组成和工作过程>微程序控制器的组成和工作过程</a></li><li><a href=#微程序设计>微程序设计</a></li></ol></li><li><a href=#指令流水线>指令流水线</a></li></ol></li><li><a href=#chapter-7-总线>Chapter 7 总线</a><ol><li><a href=#分类>分类</a></li><li><a href=#结构>结构</a></li><li><a href=#性能指标>性能指标</a></li><li><a href=#总线仲裁>总线仲裁</a><ol><li><a href=#集中式>集中式</a></li><li><a href=#分布式>分布式</a></li></ol></li></ol></li><li><a href=#chapter-8-外部设备>Chapter 8 外部设备</a><ol><li><a href=#磁介质存储器>磁介质存储器</a><ol><li><a href=#读写过程>读写过程</a></li><li><a href=#技术指标-1>技术指标</a></li><li><a href=#数字磁记录方式>数字磁记录方式</a></li></ol></li><li><a href=#磁盘存储器>磁盘存储器</a><ol><li><a href=#基本结构>基本结构</a></li><li><a href=#信息分布>信息分布</a></li><li><a href=#技术参数>技术参数</a></li><li><a href=#分区域记录>分区域记录</a></li></ol></li></ol></li><li><a href=#chapter-9-输入输出系统>Chapter 9 输入输出系统</a><ol><li><a href=#输入输出接口>输入输出接口</a><ol><li><a href=#功能-1>功能</a></li><li><a href=#组成>组成</a></li><li><a href=#类型>类型</a></li><li><a href=#外设的识别与端口寻址>外设的识别与端口寻址</a></li><li><a href=#信息传送控制方式>信息传送控制方式</a></li></ol></li><li><a href=#程序查询方式>程序查询方式</a><ol><li><a href=#工作流程>工作流程</a></li></ol></li><li><a href=#程序中断方式>程序中断方式</a><ol><li><a href=#中断>中断</a></li><li><a href=#中断源>中断源</a></li><li><a href=#中断请求信号>中断请求信号</a></li><li><a href=#中断优先级>中断优先级</a></li><li><a href=#中断响应>中断响应</a></li><li><a href=#允许和禁止中断><strong>允许和禁止中断</strong></a></li><li><a href=#中断屏蔽>中断屏蔽</a></li><li><a href=#中断全过程>中断全过程</a></li></ol></li><li><a href=#dma方式>DMA方式</a></li><li><a href=#通道控制方式>通道控制方式</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/star/ style=background-color:#2e317c;color:>一天星</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/>【计算机组成原理】笔记</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 06, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>8 minute read</time></div></footer></div></header><section class=article-content><h2 id=hint>Hint</h2><h3 id=chapter-1>chapter 1</h3><p>存储程序概念</p><h3 id=chapter-2>chapter 2</h3><p>重点IEEE754</p><h3 id=chapter-3>chapter 3</h3><p>w9 c1</p><p>3.4.10.13.14.18.22</p><p>拓展操作码-设计</p><p>EA计算</p><p>一定要画出指令结构图</p><p>标清B、H、Q</p><p><img src=https://i.ibb.co/hKhm645/image-20221216173244940.png loading=lazy alt=image-20221216173244940></p><p>位数写够</p><h3 id=chapter-4>chapter 4</h3><p>一位定点数的乘除法</p><p>w12 c3</p><p>6.8.10 (2) (4) .12</p><p>均n次移位</p><p>补乘 辅助位$y_{n+1}-y_{n}$</p><p>原除 变补</p><h3 id=chapter-5>chapter 5</h3><p>主存储器容量扩展-设计</p><p>cache计算</p><p>w10 12:13</p><p>例题</p><p>w14 c1</p><p>10.13.14.16.17.18. 25</p><p>画图标注！</p><p>Rom不连 WE非！</p><p>芯片规格、译码器规格、高低有效电平</p><p>cache</p><p>主存：区号+组号+块号+块内地址</p><p>组相联映象</p><p>主存和Cache按同样大小划分成块， 还按同样大小划分成组。</p><p>从主存的组到Cache的组之间采用直接映象方式。 在两个对应的组内部采用全相联映象（1对1）方式。</p><p><img src=https://i.ibb.co/zJr6rBy/image-20221217104226051.png loading=lazy alt=image-20221217104226051></p><h3 id=chapter-6>chapter 6</h3><p>微指令编码法-设计</p><p>6,7,9,12,13,20</p><p>参数计算公式</p><p><img src=https://i.ibb.co/ng489zb/image-20221217171233397.png loading=lazy alt=image-20221217171233397></p><p><img src=https://i.ibb.co/p32cq8f/image-20221217192938713.png loading=lazy alt=image-20221217192938713></p><p>微命令设计</p><p>结构和命令</p><p>结构画出来、阐述</p><p>命令一条条写出来</p><h3 id=chapter-89>chapter 8、9</h3><p>数字磁记录方式-画图</p><p>2.3.5</p><p>数字磁记录方式 X 7</p><p>计算</p><p>4.29.25</p><p>接口、端口</p><p>中断与子程序区别</p><p>CPU响应中断的条件</p><p>中断隐指令</p><p>允许、禁止中断</p><p>中断全过程</p><p><img src=https://i.ibb.co/vw7xLHd/image-20221218163105855.png loading=lazy alt=image-20221218163105855></p><p><img src=https://i.ibb.co/VBsRYDb/image-20221218163125391.png loading=lazy alt=image-20221218163125391></p><h2 id=chapter-2-数据的机器层次表示>Chapter 2 数据的机器层次表示</h2><h3 id=浮点表示法>浮点表示法</h3><p>$$
N=M\times r^E
$$</p><ul><li><p>r为阶码的底，与尾数的基数相同，通常 $r=2$</p></li><li><p>E为阶码（纯整数）</p><p>常用原码或补码</p></li><li><p>M为尾数（纯小数）</p><p>常用移码或补码<img src=https://i.ibb.co/G3q6h13/image-20221009205448124.png loading=lazy alt=image-20221009205448124></p></li></ul><p>假设用补码表示</p><ul><li><p>最大正数</p><p>$(1-2^{-N})\times 2^{2^K-1}$</p></li><li><p>最小正数</p><p>$(1-2^{-N})\times 2^{-2^K}$</p></li><li><p>绝对值最大负数</p><p>$-2^{2^K-1}$</p></li></ul><p>规格化浮点数：尾数最高数位为有效值
$$
\frac{1}{r}\le|M|\lt 1
$$</p><ul><li><p>规格化最小正数</p><p>$2^{-1}\times 2^{-2^K}$</p></li><li><p>规格化绝对值最小负数</p><p>$(-2^{-1}-2^{-N})\times 2^{-2^K}$</p></li></ul><h4 id=移码>移码</h4><p>同一数值的移码和补码除最高位相反外，其他各位相同</p><h4 id=ieee754>IEEE754</h4><p><img src=https://i.ibb.co/2qVBwKc/image-20221009213107297.png loading=lazy alt=image-20221009213107297></p><h3 id=非数值数据>非数值数据</h3><ul><li><p>字符串</p><ul><li>向量法</li><li>串表法</li></ul></li><li><p>国标码</p></li><li><p>区位码</p></li><li><p>机内码</p></li><li><p>汉字字形码</p></li><li><p>Unicode</p><p>16-bit</p><p>Unicode的实现方式不同于编码方式。一个字符的Unicode 编码是确定的，但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（<strong>Unicode Translation Format</strong>，简称为UTF）</p></li></ul><h2 id=chapter-3-指令系统>Chapter 3 指令系统</h2><h3 id=指令格式>指令格式</h3><ul><li>操作码：指明性质及功能</li><li>地址码：指明地址（特殊情况下也可能直接给出操作数本身）</li></ul><p>长度可以等于机器字长，也可以大于或小于机器字长</p><p>双操作数指令除操作码外：</p><ul><li>A1：第一操作数地址</li><li>A2：第二操作数地址</li><li>A3：操作结果存放地址</li><li>A4：下条将要执行指令的地址</li></ul><p>显地址：明显给出</p><p>隐地址：依照约定用隐含的方式给出</p><h4 id=操作码>操作码</h4><p>唯一标识</p><ul><li><p>规整型（定长）</p><p>简化硬件设计，减少指令译码时间，存在信息冗余</p></li><li><p>非规整型（变长）</p></li></ul><h3 id=寻址技术>寻址技术</h3><p>寻找<strong>操作数</strong>或<strong>下一条</strong>将要执行的指令<strong>地址</strong></p><p>包括编址方式和寻址方式</p><h4 id=编址方式>编址方式</h4><p>需要编址的设备：</p><ul><li>CPU中的通用寄存器</li><li>主存储器</li><li>输入输出设备</li></ul><p>编址单位</p><ul><li>字编址：编址单位=访问单位</li><li>字节编址：编址单位&lt;访问单位</li><li>位编址</li></ul><p>地址码位数与主存容量和最小寻址单位（编址单位）有关</p><p><strong>寻址</strong></p><ul><li><p><strong>数据寻址</strong></p></li><li><p>指令寻址</p><p>寻找下一条执行指令</p><ul><li><p>顺序寻址</p><p>程序计数器PC+1</p></li><li><p>跳跃寻址</p><ul><li>直接（绝对）寻址</li><li>相对寻址</li><li>间接寻址</li></ul></li></ul></li></ul><h4 id=数据寻址>数据寻址</h4><p>寻找操作数地址</p><ul><li><p>立即寻址</p><p>op|立即数</p></li><li><p>寄存器寻址</p><p>优点</p><ul><li>快</li><li>地址码短</li></ul></li><li><p>直接寻址</p><p>地址码给出的地址即为操作数地址</p><p>操作数地址不能修改，与程序本身所在位置无关，又称为绝对寻址</p></li><li><p>间接寻址</p><p>地址码给出的地址指向操作数的存放地址</p><p>通常在指令格式中划出一位@为标志位</p><ul><li><p>@=0 直接寻址</p></li><li><p>@=1 间接寻址</p></li><li><p>多级间接寻址</p><p>0 找到有效地址</p><p>1 继续间接寻址</p></li></ul></li><li><p>寄存器间接寻址</p></li><li><p>变址寻址</p><p>把指令给出的形式地址A与变址寄存器Rx的内容相加</p><p>面向用户，访问字符串、向量和数组等批数据</p></li><li><p>基址寻址</p><p>把基址寄存器Rb的内容与位移量相加</p><p>位移量可正可负</p><p>面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题</p></li><li><p>页面寻址</p><p>将整个主存空间分成若干个大小相同的区，每个区成为一页</p><p>页面地址：页编号</p><p>业内地址：页内单元编号</p><ul><li>基页（零页）寻址</li><li>当前页寻址
页面地址等于程序计数器pc的高位部分</li><li>页寄存器寻址</li></ul></li></ul><p><img src=https://i.ibb.co/GcSMbWF/image-20221030172309408.png loading=lazy alt=image-20221030172309408></p><h5 id=区分寻址>区分寻址</h5><ul><li><p>显式</p><p>OP|MOD|A</p></li><li><p>隐式</p><p>OP|A</p></li></ul><h3 id=堆栈>堆栈</h3><ul><li><p>寄存器堆栈（硬堆栈）</p><p>寄器组相互连接，栈顶固定，具有对应位自动推移功能</p></li><li><p>存储器堆栈（软堆栈）</p><p>栈底固定，栈顶浮动，高地址向低地址生长，SP指针</p></li></ul><h3 id=指令类型>指令类型</h3><ul><li><p>数据传送类指令</p><p>实现寄存器之间，寄存器与主存单元之间，主存单元之间数据</p><ul><li>一般传送</li><li>堆栈操作</li><li>数据交换</li></ul></li><li><p>运算类指令</p><ul><li>算术运算</li><li>逻辑运算</li><li>移位<ul><li>算术移位</li><li>逻辑移位</li><li>循环移位</li></ul></li></ul></li><li><p>程序控制类</p><ul><li><p>无条件转移</p><p>JMP</p></li><li><p>子程序调用</p><p>CALL</p><p>RET</p></li></ul></li><li><p>输入输出类</p><ul><li><p>独立编址</p><p>把外设端口和主存单元分别独立编址</p><p><img src=https://i.ibb.co/f19tmQX/image-20221030182945796.png loading=lazy alt=image-20221030182945796></p></li><li><p>统一编址</p><p>把外设寄存器和主存单元统一编址</p><p><img src=https://i.ibb.co/RSb4YXz/image-20221030182959953.png loading=lazy alt=image-20221030182959953></p></li></ul></li></ul><h3 id=发展>发展</h3><ul><li>复杂指令系统计算机 CISC</li><li>精简指令系统计算机 RISC</li></ul><h2 id=chapter-4-数值的机器运算>Chapter 4 数值的机器运算</h2><h3 id=加法器-不要求>加法器 （不要求？）</h3><p>加法器是由<strong>全加器</strong>再配以<strong>其他必要的逻辑电路</strong>组成的</p><p><img src=https://i.ibb.co/GPvSwcK/image-20221204141723724.png loading=lazy alt=image-20221204141723724>
$$
S_i=A_i\oplus B_i\oplus C_{i-1}
\
C_i=A_iB_i+(A_i\oplus B_i)C_{i-1}
$$</p><ul><li><p>串行加法器</p><p>只有一个全加器。数据逐位串行送入加法器进行运算</p></li><li><p>并行加法器</p><p>由多个全加器组成。提高其速度的关键是尽量加快进位的产生和传递的速度。</p><p>若不考虑$G_i$、$P_i$的形成时间，从$C_0->C_n$的最长延迟时间为 $2nty$</p></li></ul><h4 id=并行快速进位>并行快速进位</h4><p>$$
C_i=A_iB_i+(A_i\oplus B_i)C_{i-1}
$$</p><p>令</p><p>$G_i=A_iB_i$，表示若本位的两个输入均为1，必然要向高位产生进位</p><p>$P_i=A_i\oplus B_i$，表示当两个有入中一个为1，低位进位$C_{i-1}$将超越本位向更高位传送
$$
C_i=G_i+P_iC_{i-1}
$$
由此可得<strong>并行加法器的快速进位</strong>
$$
G_0=C_0
\
C_i=\sum_{j=0}^iG_i\Pi_{k=j+1}^iP_{k}
$$
<img src=https://i.ibb.co/yRHkskj/image-20221204145851973.png loading=lazy alt=image-20221204145851973></p><h4 id=分组并行进位>分组并行进位</h4><p>把n位字长分为若干小组，在组内各位之间实行并行快速进位，组间采用串行进位或并行快速进位</p><h5 id=单级先行进位方式>单级先行进位方式</h5><p>组内并行，组间串行</p><p>CLA: Carry-Lookahead Adder</p><p><img src=https://i.ibb.co/mvXkr2V/image-20221204150548543.png loading=lazy alt=image-20221204150548543></p><p>若不考虑$G_i$、$P_i$的形成时间，从$C_0->C_n$的最长延迟时间为 $2kty$，其中k为组数</p><h5 id=多级先行进位方式>多级先行进位方式</h5><p>组内并行，组间并行</p><p>BCLA: Blocked Carry-Lookahead Adder</p><p><img src=https://i.ibb.co/bJbD7SF/image-20221204151537333.png loading=lazy alt=image-20221204151537333></p><p>若不考虑$G_i$、$P_i$的形成时间，从$C_0->C_n$的最长延迟时间为 $6ty$</p><p><img src=https://i.ibb.co/fHwx6MR/image-20221204152740583.png loading=lazy alt=image-20221204152740583></p><h3 id=定点乘法>定点乘法</h3><p><strong>寄存器</strong></p><ul><li><p>A寄存器：部分积与最后乘积的<strong>高位部分</strong>，初值为0。</p></li><li><p>B寄存器：被乘数X。</p></li><li><p>C寄存器：乘数Y，运算后C寄存器中不再需要保留乘数，改为存放乘积的<strong>低位部分</strong>。</p></li></ul><h4 id=原码一位乘法>原码一位乘法</h4><p><strong>规则</strong></p><ol><li>参加运算的操作数取其绝对值</li><li>令乘数的最低位为判断位，若为 “1”，加被乘数，若为“0”，不加被乘数 （加0）；</li><li>累加后的部分积<strong>右移</strong>一位；</li><li>重复n次（前提为n个数值位，1个符号位）2.和3.；</li><li>符号位单独处理，同号为正，异号为负。</li></ol><p><strong>summary</strong></p><p>右移n次，变乘为加</p><h4 id=补码一位乘法>补码一位乘法</h4><p><strong>规则</strong></p><ol><li>参加运算的数用<strong>补码</strong>表示；</li><li>符号位参加运算；</li><li>乘数最低位后面增加一位附加位 $Y_{n+1}$，其初值为0；</li><li>由于每求一次部分积要<strong>右移</strong>一位， 所以乘数的最低两位$Y_n$、$Y_{n+1}$的值决定了每次应执行的操作；</li><li>移位按补码右移规则进行</li><li>共需做n+1次累加，n次移位，第 n+1次不移位。</li></ol><p><strong>summary</strong></p><p>永远右移，$Y_{i+1}-Yi$</p><ul><li><p>$\gt0$：加X（补）</p></li><li><p>$\lt0$：减X（补）</p></li></ul><h3 id=定点除法>定点除法</h3><p><strong>寄存器</strong></p><ul><li>A寄存器：存放被除数X，最后A寄存器中剩下的是扩大了若干倍的余数。运算过程中A寄存器的内容将不断地发生变化</li><li>B寄存器：存放除数Y</li><li>C寄存器：存放商Q，它的初值为0</li></ul><h4 id=原码加减交替法>原码加减交替法</h4><p><strong>规则</strong></p><ol><li><p>被除数减去除数</p></li><li><p>当余数为正时，商为“1”，余数<strong>左移</strong>一位，减除数</p><p>当余数为负时，商为“0”，余数<strong>左移</strong>一位，加除数</p></li><li><p>重复步骤2.，做n+1步加减运算(n步移位)</p></li><li><p>若余数为负回正（第n+2步）</p></li></ol><h4 id=补码加减交替法>补码加减交替法</h4><p><strong>规则</strong></p><ol><li><p>被除数与除数同号，被除数减去除数；被除数与除数异号，被除数加上除数。</p></li><li><p>余数和除数同号，商上1，余数左移一位，下次减除数</p><p>余数和除数异号，商上0，余数左 移一位，下次加除数</p></li><li><p>重复步骤2.，包括符号位在内，共做n+1步加减运算(n步移位)。</p></li><li><p>商的末位恒置1</p></li></ol><h3 id=规格化浮点数运算>规格化浮点数运算</h3><p>$$
A=M_A\times2^{E_A}
\
B=M_B\times2^{E_B}
$$</p><p>仅要求加减</p><ol><li><p><strong>对阶</strong>：小阶向大阶看齐，尾数右移</p></li><li><p>尾数加/减</p></li><li><p>尾数结果规格化</p><ul><li><p>左规</p><p>若干次</p></li><li><p>右规</p><p>假溢出 1次</p></li></ul></li></ol><h2 id=chapter-5-存储系统>Chapter 5 存储系统</h2><ul><li><p>由几个容量、速度和价格各不相同的存储器构成的系统</p><ul><li>从CPU的角度来看，n种不同的存储器 （$M_1$～$M_n$）在逻辑上是一个整体，整个存储系统具有</li><li>接近于$M_1$的速度</li><li>相等或接近$M_n$的容量</li><li>接近于$M_n$的位价格</li></ul></li><li><p>Cache存储系统是为解决主存速度不足而提出来的</p><p>它对系统 程序员和应用程序员都是透明的</p><p><img src=https://i.ibb.co/72Gg9tM/image-20221031213210544.png loading=lazy alt=image-20221031213210544></p></li><li><p>虚拟存储系统是为解决主存容量不足而提出来的</p><p>虚拟存储系统需要通过操作系统调度，因此对系统程序员是不透明的， 但对应用程序员是透明的</p><p><img src=https://i.ibb.co/VQpS9WZ/image-20221031213412473.png loading=lazy alt=image-20221031213412473></p></li></ul><h3 id=存储器>存储器</h3><ul><li><p>按作用分类</p><ul><li><p>高速缓冲存储器</p><p>主存与CPU之间</p></li><li><p>主存储器</p><p>CPU可直接随机访问</p></li><li><p>辅助存储器</p><p>CPU不能直接访问</p></li></ul></li><li><p>按存取方式分类</p><ul><li><p>随机存取存储器RAM</p><p>CPU可随机读写访问，存取时间相同</p></li><li><p>只读存储器ROM</p><p>可视为特殊只读RAM</p></li><li><p>顺序存取存储器SAM</p><p>只能按某种顺序存取，存取时间与物理位置有关</p></li><li><p>直接存取存储器DAM</p></li></ul></li><li><p>按存储介质分类</p><ul><li><p>磁芯存储器</p><p>不会因断电丢失；破坏性读出</p></li><li><p>半导体存储器</p><p>双极型（TTL或ECL电路）和MOS型</p></li><li><p>磁表面存储器</p></li><li><p>光存储器</p></li></ul></li><li><p>按信息的可保存性</p><ul><li><p>易失性存储器</p><p>断电后存储信息即消失</p></li><li><p>非易失性存储器</p><p>断电后信息仍保存</p></li></ul></li></ul><h3 id=主存>主存</h3><ul><li><p>存储体</p><p>核心，存放程序和数据</p></li><li><p>地址译码驱动电路</p><p>包含</p><ul><li><p>译码器</p><p>将地址总线输入的地址码转换成与之对应的译码输出线上的有 效电平，以表示选中了某一单元</p></li><li><p>驱动器</p><p>提供驱动电流去驱动相应的读、写电路， 完成对被选中单元的读、写操作</p></li></ul></li><li><p>I/O和读写电路</p><ul><li>放大器</li><li>写入电路</li><li>读/写控制电路</li></ul></li></ul><p><img src=https://i.ibb.co/BgLx3BV/image-20221031213519616.png loading=lazy alt=image-20221031213519616></p><p>字节编址</p><ul><li><p>大端方案</p><p>高字节存放在低地址</p><p><img src=https://i.ibb.co/FYxbDxn/image-20221031214408948.png loading=lazy alt=image-20221031214408948></p></li><li><p>小端方案</p><p>高字节存放在高地址</p><p><img src=https://i.ibb.co/bzsvTwW/image-20221031214358395.png loading=lazy alt=image-20221031214358395></p></li></ul><h4 id=技术指标>技术指标</h4><ul><li><p>存储容量</p><p>主存所能容纳的二进制信息总量</p></li><li><p>存取速度</p><ul><li><p>存取时间</p><p>从启动以此存储器操作到完成该操作所经历的时间</p></li><li><p>存取周期</p><p>存储器进行以此完整的读写操作所需要的全部时间，即连续两次访问存储器操作之间所需要的最短时间</p><p>在读写操作之后， 总要有一段恢复内部状态的复原时间</p></li></ul></li><li><p>主存带宽</p><p>数据传输率 Bps,bps,Wps</p><p>Bm =主存等效工作频率×主存位宽 ÷8</p><p>​ =内存时钟频率×倍增系数×主存位数 ÷ 8（不做要求）</p><p>提高措施</p><ul><li>缩短存取周期</li><li>增加存储字长</li><li>增加存储体</li></ul></li></ul><h3 id=半导体随机存储器和只读存储器>半导体随机存储器和只读存储器</h3><p>主存储器通常分为RAM和ROM两大部分</p><h3 id=ram>RAM</h3><ul><li><p>记忆单元</p><p>存放一个二进制位的物理器件，是存储器的最基本构件</p><p>记忆单元可以由各种材料制成，但最常见的由<strong>MOS电路</strong>组成。MOS型存储器根据记忆单元的结构又可分为静态RAM和动态RAM两种。</p><ul><li>静态RAM，即SRAM（Static RAM），其存储电路以<strong>双稳态触发器</strong>为基础；</li><li>动态RAM，即DRAM（Dynamic RAM），其存储电路以<strong>电容</strong>为基础。</li></ul></li><li><p>存储单元</p><p>由地址码相同的多个记忆单元构成</p></li></ul><h4 id=dram>DRAM</h4><p><strong>刷新</strong></p><p>为了维持MOS型动态记忆单元的存储信息，每隔一定时间<strong>对存储体中的所有记忆单元的栅极电容补充电荷</strong>的过程</p><p>一般选定MOS型动态存储器允许的最大刷新间隔为2ms，也就是说，应在 2ms内，将全部存储体刷新一遍。</p><p><strong>刷新 vs. 重写（再生）</strong></p><ul><li>重写是<strong>随机</strong>的，一般按<strong>存储单元</strong>进行的，某个存储单元只有在<strong>破坏性读出</strong>之后才需要重写</li><li>刷新是<strong>定时</strong>的，通常以<strong>存储体矩阵中的一行</strong>为单位进行，即使许多记忆单元长期未被访问，若不及时补充电荷的话，信息也会丢失。</li></ul><p><strong>刷新方式</strong></p><ul><li><p>集中式</p><p>在允许的最大刷新间隔内，按照存储芯片容量的大小集中安排若干个刷新周期， 刷新时停止读写操作。</p><p>刷新时间=存储体矩阵行数×刷新周期</p><p>这里刷新周期是指刷新一行所需要的时间，由于刷新过程就是“假读”的过程， 所以刷新周期就等于存取周期。</p><p><img src=https://i.ibb.co/PQb9z3w/image-20221112121550108.png loading=lazy alt=image-20221112121550108></p><p>优点：读/写操作时不 受刷新工作的影响，因此系统的存取速度比较高。</p><p>缺点：在集中刷新期间必须停止 读/写，这一段时间称为“死区”，而且存储容量越大，死区就越长。</p></li><li><p>分散式</p><p>把刷新操作分散到每个存取周期内进行，此时系统的存取周期被分为两部分，前一部分时间进行读/写操作或保持，后一部分时间进行刷新操作。一个系统存取周期内刷新存储矩阵中的一行。</p><p><img src=https://i.ibb.co/MVHB7Xw/image-20221112121815318.png loading=lazy alt=image-20221112121815318></p><p>优点：没有死区</p><p>缺点：</p><p>加长了系统的存取周期</p><p>刷新过于频繁，尤其是当存储容量比较小的情况下，没有充分利用所允许的最大刷新间隔（2ms）</p></li><li><p>异步式</p><p>结合集中式和分散式，它充分利用了最大刷新间隔时间， 把刷新操作平均分配到整个最大刷新间隔时间内进行</p><p>相邻两行的刷新间隔=最大刷新间隔时间/行数</p><p><img src=https://i.ibb.co/86LX2cD/image-20221112122106487.png loading=lazy alt=image-20221112122106487></p></li></ul><p><strong>刷新控制</strong></p><ul><li>对CPU是透明的。</li><li>刷新通常是一行一行地进行的，每一行中各记忆单元同时被刷新，故刷新操作时仅需要行地址，不需要列地址</li><li>刷新操作类似于读出操作</li><li>因为所有芯片同时被刷新，所以在考虑刷新问题时，应当从单个芯片的存储容量着手，而不是从整个存储器的容量着手</li></ul><h4 id=ram芯片分析>RAM芯片分析</h4><p>存储芯片通过<strong>地址线、数据线和控制线</strong>与外部连接。</p><ul><li><p>地址线</p><p>单向输入的，其数目与<strong>芯片容量</strong>有关。如容量为1024×4时，地址线 有10根；容量为64K×1时，地址线有16根</p></li><li><p>数据线</p><p>双向的，既可输入，也可输出，其数目与<strong>数据位数</strong>有关。如1024×4的芯片，数据线有4根；64K×1的芯片，数据线只有1根。</p></li><li><p>控制线</p><p>主要有读/写控制线（或写允许线）和片选线两种，读/写控制线是用来决定芯片是<strong>进行读操作还是写操作</strong>，片选线是用来决定 该芯片<strong>是否被选中</strong>的</p></li></ul><p><strong>地址复用</strong></p><p>由于DRAM芯片<strong>集成度高，容量大</strong>，为了减少芯片引脚数量，DRAM芯片把地址线分成相等的两部分，分两次从相同的引脚送入。两次输入的地址分别称为行地址和列地址，行地址由行地址选通信号送入存储芯片，列地址由列地址选通信号送入存储芯片。由于采用了地址复用技术， 因此，<strong>DRAM芯片每增加一条地址线，实际上是增加了两位地址，也即增加了4倍的容量</strong>。</p><p><strong>地址译码</strong></p><p>地址译码电路把地址线送来的<strong>地址信号</strong>翻译成对应存储单元的<strong>选择信号</strong></p><ul><li><p>单译码</p><p>又称<strong>字选法</strong>，它所对应的存储器结构是<strong>字结构</strong>的，容量为M个字的存储器（M个字，每字b位），排列成M行×b列的矩阵，矩阵的每一行对应一个字， 有一条公用的选择线wi （字线）。字线选 中某一行时，同一行中的各位就都被选中， 由读写电路对被选中的各位实施读出或写 入操作。</p><p>优点：结构简单</p><p>缺点：使用的外围电路多，成本昂贵。更严重的是，当 字数大大超过位数时，存储器会形成纵向很长而横向很窄的不合理结构，所以这种方式只适用于<strong>容量不大的存储器</strong>。</p></li><li><p>双译码</p><p>又称为重合法。通常是把K位地址码分成接近相等的两段，一段用于水平方向作X地址线，供X地址译码器译码； 一段用于垂直方向作Y地址线，供Y地址译码器译码。X和Y两个方向的选择线在存储体内部的一个记忆单元上交叉，以选择相应的记忆单元</p><p><img src=https://i.ibb.co/ySRbcfv/image-20221112123522903.png loading=lazy alt=image-20221112123522903></p><p>双译码方式对应的存储芯片结构可以是<strong>位结构</strong>的，则在Z方向上重叠b个芯片，也可以是<strong>字段结构</strong>的。</p><p>以Intel 2114为例</p><p>存储容量为1K×4，由4096个六管记忆单元电路组成，它们排成64×64的矩阵， 采用字段结构。CPU送来的地址总线10位 （A0～A9），其中<strong>6位</strong>作为行选择电路的输入，经行地址译码器产生64条行选择线； 另<strong>4位</strong>作为列选择电路的输入，经列地址译码器产生16条列选择线，每条列选择线再经列I/O电路把4条数据线（I/O1～I/O4）连接到各字段的相应位上</p><p><img src=https://i.ibb.co/M79SQYy/image-20221112124627393.png loading=lazy alt=image-20221112124627393></p></li></ul><p>CS：Chip Select</p><p>WE：write</p><h3 id=rom>ROM</h3><p>具有非易失性，即使电源断电，ROM中存储的信息也不会丢失</p><p>我们把向ROM写入数据的过程称为对ROM进行<strong>编程</strong>，根据编程方法的不同，ROM通常可以分为以下几类：</p><ul><li><p>掩膜式ROM（MROM）</p><p>内容是由半导体生产厂家按用户提出的要求在芯片的生产过程中直接写入的， 写入后任何人都无法改变其内容。</p></li><li><p>一次可编程ROM（PROM）</p><p>PROM允许用户利用专门的设备（编程器或写入器）写入自己的程序，但一旦写入后便无法改变，因此它是一种一次性可编程的ROM。</p><p>通常，生产厂家提供的PROM芯片初始内容为全“0”，用户根据自编的程序， 使用编程器外加足够大的电压（或电流）， 将“1”写入相应位，PROM的编程是逐位进行的。常见的PROM根据写入原理可分为两类：结破坏型和熔丝型。</p></li><li><p>可擦除可编程ROM（EPROM）</p><p>内容不仅可以由用户利用编程器写入，而且可以对其内容进行多次改写。但要注意的是：在+5V的电源条件下只能读出不能写入，用编程器写入信息时必须用+25V的高压。与前两种ROM相 比，EPROM使用起来最为方便，因此应用非常广泛</p><ul><li><p>UVEPROM（紫外线擦除）</p><p>用紫外线灯进行擦除的，所以只能对<strong>整个芯片擦除</strong>，而不能对芯片中个别需要改写的存储单元单独擦除和重写。</p></li><li><p>EEPROM（电擦除）</p><p>用电气方法来进行擦除的，它在联机 条件下可以用<strong>字擦除</strong>方式擦除，也可以用数据块擦除方式擦除。以字擦除方式操作时，能够只擦除被选中的那个存储单元的内容；在数据块擦除方式操作时，可擦除数据块内所有单元的内容。</p></li></ul><p><strong>选择题</strong></p></li><li><p>闪速存储器（flash memory）</p><p>一种快擦写型存储器，它的主要特点 是：既可在不加电的情况下长期保存信息， 又能在线进行快速擦除与重写，兼备了 EEPROM和RAM的优点。 目前，大多数微机的主板采用闪速存储器来存储BIOS（基本输入/输出系统）程序。闪速存储器除了具有ROM的一般特性外，还有低电压改写的特点，便于用户自动升级BIOS</p></li></ul><h3 id=主存储器的连接与控制>主存储器的连接与控制</h3><h4 id=主存容量的扩展>主存容量的扩展</h4><p>要组成一个主存，首先要考虑<strong>选片</strong>的问题，然后就是如何把芯片<strong>连接</strong>起来的问题。 根据存储器所要求的容量和选定的存储芯片的容量，就可以计算出总的芯片数，即</p><p>总片数＝ 总容量 /芯片容量</p><p><strong>位拓展</strong></p><p>在位数方向扩展（加大字长），而芯片的字数和存储器的字数是一致的。</p><p>位扩展的连接方式是将各存储芯片的<strong>地址线、片选线和读/写线相应地并联起来</strong>， 而将各芯片的数据线单独列出</p><p><img src=https://i.ibb.co/b5JysXY/image-20221112145434593.png loading=lazy alt=image-20221112145434593></p><p><img src=https://i.ibb.co/Krg2zRm/image-20221112145452733.png loading=lazy alt=image-20221112145452733></p><p>当CPU访问该存储器时，其发出的地址和控制信号同时传给8个芯片，选中每个芯片的同一单元，其单元的内容被同时读至数据总线的相应位，或将数据总线上的内容分别同时写入相应单元。</p><p><strong>字拓展</strong></p><p>仅在字数方向扩展，而位数不变。字扩展将芯片的<strong>地址线、数据线、 读/写线并联</strong>，由片选信号来区分各个芯片。</p><p><img src=https://i.ibb.co/pdXt9xG/image-20221112145333561.png loading=lazy alt=image-20221112145333561></p><p><img src=https://i.ibb.co/kJqtvnJ/image-20221112145417166.png loading=lazy alt=image-20221112145417166></p><p><strong>字和位同时扩展</strong></p><p>当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展， 这是前两种扩展的组合。</p><p><img src=https://i.ibb.co/3hBj4Kz/image-20221112145637369.png loading=lazy alt=image-20221112145637369></p><p><strong>10周 例题x2</strong></p><p><strong>重点：设计、cache计算</strong></p><h4 id=地址分配和片选>地址分配和片选</h4><p>CPU要实现对存储单元的访问，首先要选择存储芯片，即进行<strong>片选</strong>；然后再从选中的芯片中依地址码选择出相应的存储单元，以进行数据的存取，这称为<strong>字选</strong>。</p><p><strong>片内的字选是由CPU送出的N条低位地址线完成</strong>的，地址线直接接到所有存储芯片的地址输入端（N由片内存储容量$2^N$决定）， <strong>而片选信号则是通过高位地址得到</strong>的。
实现片选的方法可分为3种：</p><ul><li><p>线选法(CPU地址信号远高于设计需求，仅需<strong>直连</strong>)</p><p>是用除片内寻址外的高位地址线直接（或经反相器）分别接至各个存储芯片的片选端，当某地址线信息为“0”时，就选中与之对应的存储芯片。</p><p>优点：不需要地址译码器，线路简单，选择芯片不需要外加逻辑电路</p><p>缺点：</p><p>仅适用于连接存储芯片较少的场合。</p><p>不能充分利用系统的存储器空间，且把地址空间分成了相互隔离的区域，给编程带来了一定的困难</p></li><li><p>全译码法（CPU地址信号等于设计需求）</p><p>全译码法将片内寻址外的<strong>全部高位地址线</strong>作为地址译码器的输入，把经译码器译码后的输出作为各芯片的片选信号，将它们分别接到存储芯片的片选端，以实现对存储芯片的选择。 全译码法的优点是每片（或组）芯片的地址范围是<strong>唯一确定</strong>的，而且是连续的， 也便于扩展，不会产生地址重叠的存储区， 但全译码法对译码电路要求较高。</p></li><li><p>部分译码法</p><p>所谓部分译码即用片内寻址外的<strong>高位地址的一部分</strong>来译码产生片选信号。 如用4片2K×8的存储芯片组成8K×8存 储器，需要四个片选信号，因此只要用两位地址线来译码产生。</p><p>设地址总线有20位 （A19～A0），则寻址8K×8存储器时，无论 A19 ～A13 取何值，只要A12 =A11 =0，而均选 第一片，只要A12 =0，A11 =1，均选中第 二片，……。也就是说，8K RAM中的<strong>任一个存储单元，都对应有2(20-13) =27 个地址</strong>，这种一个存储单元出现多个地址的现象称<strong>地址重叠</strong></p><p>令未用到的高位地址全为0，这样确定的存储器地址称为<strong>基本地址</strong>，本例中 8K×8存储器的基本地址即00000H～ 01FFFH。</p><p>部分译码法较全译码法简单， 但存在地址重叠区</p></li></ul><h4 id=主存与cpu连接>主存与CPU连接</h4><p><strong>硬连接</strong></p><p>主存与CPU的硬连接有三组连线：</p><ul><li>地址总线（AB）</li><li>数据总线（DB）</li><li>控制总线（CB）</li></ul><p><img src=https://i.ibb.co/ngMhstf/image-20221112153416156.png loading=lazy alt=image-20221112153416156></p><p>此时，我们把主存看作一个黑盒子，<strong>存储器地址寄存器（MAR）<strong>和</strong>存储器数据寄存器（MDR）<strong>是主存和CPU之间的</strong>接口</strong>。</p><p>MAR可以接受来自程序计数器的指令地址或来自运算器的操作数地址，以确定要访问的单元。</p><p>MDR是向主存写入数 据或从主存读出数据的缓冲部件。</p><p><strong>基本操作</strong></p><p>CPU与主存的硬连接是<strong>两个部件之间联系的物理基础</strong>，而两个部件之间还有软连接，即<strong>CPU向主存发出的读或写命令</strong>， 这才是两个部件之间有效工作的关键。</p><p>CPU对主存进行读/写操作时，首先 CPU在地址总线上给出<strong>地址信号</strong>，然后发出相应的<strong>读写命令</strong>，并在<strong>数据总线</strong>上交换信息。</p><ul><li><p>读</p><p>从CPU送来的地址所指定的存储单元中取出信息，再送给CPU</p><ul><li><p>地址→MAR→AB CPU</p><p>将地址信号送至地址总线</p></li><li><p>Read</p><p>CPU发读命令</p></li><li><p>Wait for MFC</p><p>等待存储器工作完成信号</p></li><li><p>((MAR))→DB→MDR</p><p>读出信息经数据总线送至CPU</p></li></ul></li><li><p>写</p><p>写操作是指将要写入的信息存入CPU 所指定的存储单元中</p><ul><li><p>地址→MAR→AB</p><p>CPU将地址信号送至地址总线</p></li><li><p>数据→MDR→DB</p><p>CPU将要写入的数据送至数据总线</p></li><li><p>Write</p><p>CPU发写命令</p></li><li><p>Wait for MFC</p><p>等待存储器工作完成信号</p></li></ul></li></ul><p>由于CPU和主存的速度存在着差距，所以两者之间的速度匹配是很关键的，通常有两种匹配方式：</p><ul><li>同步存储器读取</li><li>异步存储器读取</li></ul><p>上面给出的读/写基本操作是以异步存储器读取来考虑的，CPU和主存间没有统一的时钟，由存储器工作完成信号 （MFC）通知CPU存储器工作已完成。 对于同步存储器读取，CPU和主存采用统一时钟，因为主存速度较慢，所以CPU与 之配合必须放慢速度。</p><h3 id=高速缓冲存储器>高速缓冲存储器</h3><p><strong>程序的局部性原理</strong></p><p>程序的局部性包括：</p><ul><li><p>时间局部性</p><p>如果一个存储单元被访问，则可能该单元会很快被再次访问，这是因为程序存在着循环</p></li><li><p>空间局部性</p><p>空间局 部性是指如果一个存储单元被访问，则该单元邻近的单元也可能很快被访问，这是因为程序中大部分指令是顺序存储、顺序执行的，数据一般也是以向量、数组、树 、表等形式簇聚地存储在一起的</p></li></ul><p>高速缓冲技术就是利用程序的局部性原理，把程序中正在使用的部分存放在一 个高速的容量较小的Cache中，<strong>使CPU的访存操作大多数针对Cache进行</strong>，从而使程序的执行速度大大提高</p><p><strong>基本结构</strong></p><p>Cache和主存都被分成若干个大小相等的块，每块由若干字节组成。由于Cache的容量远小于主存的容量，它保存的信息只是<strong>主存中最活跃的若干块的副本</strong></p><p><strong>读写操作</strong></p><ul><li><p>读</p><p>当CPU发出读请求时，如果Cache命中 ，就直接对Cache进行读操作，与主存无关 ；如果Cache不命中，则仍需访问主存，并把该块信息一次从主存调入Cache内。若此时Cache已满，则需根据某种<strong>替换算法</strong>，用 这个块替换掉Cache中原来的某块信息</p></li><li><p>写</p><p>当CPU发出写请求时，如果Cache命中 ，会遇到如何保持Cache与主存中的<strong>内容一致</strong>的问题，处理的方法有：</p><ul><li>写直达法</li><li>写回法</li></ul><p>如果Cache不命中，就直接把信息写入主存，而与Cache无关</p></li></ul><p><strong>命中率</strong></p><p>在一个程序执行期间 ，设$N_c$表示Cache完成存取的总次数，$N_m$表示主存完成存取的总次数，$h$定义为命中率。则有:
$$
h=\frac{N_c}{N_c+N_m}
$$
<strong>效率</strong></p><p>Cache –主存系统的效率 $e$：
$$
e=\frac{访问cache时间}{平均访问时间}\times 100%
$$
$e$与Cache命中率有关，设Cache命中率为$h$，访问 Cache 的时间为$t_c$， 访问主存的时间为$t_m$ 则:
$$
e =\frac{t_c}{h\times t_c+(1-h)\times t_m} × 100%
$$
<strong>地址变换</strong></p><p>当程序已经装入到Cache之后，在实际运行过程中，把主存地址变换成Cache地址</p><p><strong>地址映象</strong></p><p>把存放在主存中的程序按照某种规则装入到Cache中，并建立主存地址与Cache地址之间的对应关系</p><ul><li><p><strong>全相联映象</strong></p><p>主存中的任意一块都可以映象到Cache中的任意一块。如果Cache的块数为Cb，主存的块数为 Mb，映象关系共有：Cb×Mb种,用硬件实现非常复杂</p><p>优点：</p><ul><li>块冲突概率比较小</li><li>Cache的利用率高</li></ul><p>缺点:</p><ul><li>需要一个相联存储器，其代价很高。</li><li>相联比较所花费的时间将影响Cache的访问速度</li></ul></li><li><p><strong>直接映象</strong></p><p>主存中一块只能映象到 Cache的一个特定的块中</p><p>b＝B mod Cb，其中： b为Cache的块号， B是主存的块号， Cb是Cache的块数。</p><p>整个Cache地址与主存地址的低位部分完全相同。</p><p>优点：</p><ul><li><p>硬件实现很简单, 不需要相联访问存储器。</p></li><li><p>访问速度也比较快, 实际上不做地址变换。</p></li></ul><p>缺点：</p><ul><li>块的冲突率较高。</li></ul><p>提高Cache速度的一种方法： 把区号存储器与Cache合并成一个存储器</p></li><li><p><strong>组相联映象</strong></p><p>组相联映像实际上是全相联映像和直接映像的<strong>折衷方案</strong></p><p>主存和Cache按同样大小划分成块， 还按同样大小划分成组。 从主存的组到Cache的组之间采用直接映象方式。 在两个对应的组内部采用全相联映象方式。</p><p>优点：</p><ul><li>块的冲突概率比较低； 块的利用率大幅度提高；</li><li>块失效率明显降低。</li></ul><p>缺点：</p><ul><li>实现难度和造价要比直接映象方式高</li></ul><p>(地址变换过程自己看，不要求）</p></li></ul><p>选取地址映象方法的主要依据：</p><ul><li>地址变换的硬件要容易实现</li><li>地址变换的速度要快</li><li>主存空间利用率要高</li><li>发生块冲突的概率要小</li></ul><p>（虚存类似，跳过？）</p><h2 id=chapter-6-cpu>Chapter 6 CPU</h2><h3 id=功能和组成>功能和组成</h3><p>计算机的工作过程就是程序的运行过程，也 就是<strong>在控制器的控制下逐条执行程序中各指令的过程</strong>。在程序运行过程中，计算机的各部件在控制器的控制下有条不紊地工作，在各部件之间流动的指令和数据形成了<strong>指令流</strong>和<strong>数据流</strong>。</p><p>从程序运行的角度来看，<strong>控制器</strong>的基本功能是<strong>对指令流和数据流在时间与空间上实施正确的控制</strong>。</p><less important><ul><li>对指令流的控制<ul><li>指令流出的控制</li><li>指令分析与执行的控制</li><li>指令流向的控制</li></ul></li><li>对数据流的控制<ul><li>对数据的流入与流出的控制</li><li>对数据变换、加工等操作的控制</li></ul></li></ul><p>&lt;/less important></p><p>对于冯·诺依曼结构的计算机而言， 数据流是根据指令流的操作而形成的，也就是说数据流是由指令流来驱动的</p><h4 id=主要寄存器>主要寄存器</h4><p>用来暂时保存在运算和控制过程中的<strong>中间结果、最终结果以及控制、状态信息</strong>的，又可分为通用寄存器和专用寄存器两种</p><ul><li><p>通用寄存器</p><p>可用来存放原始数据和运算结果，有的还可以作为变址寄存器、计数器、地址指针等。</p><p>一般可以由CPU<strong>直接</strong>访问</p></li><li><p>专用寄存器</p><p>专门用来完成某一种特殊功能的寄存器。</p><p>CPU中至少要有五个专用的寄存器。它们是：程序计数器（PC）、 指令寄存器（IR）、存储器地址寄存器 （MAR）、存储器数据寄存器（MDR）、 状态标志寄存器（PSWR）</p><ul><li><p><strong>程序计数器</strong></p><p>程序计数器用来存放<strong>正在</strong>执行的指令地址或<strong>接着</strong>要执行的下条指令地址。</p><p>对于顺序执行的情况，PC的内容应不断地增量（加“1”），以控制指令的顺序执行。</p><p>在遇到需要改变程序执行顺序的情况时，将<strong>转移的目标地址送往PC</strong>，即可实现 、程序的转移。在有些情况下除需要改变PC 的内容外，还需要保留PC过去的内容，以便返回时使用</p></li><li><p><strong>指令寄存器</strong></p><p>指令寄存器用来存放<strong>从存储器中取出的指令</strong>。当指令从主存取出暂存于指令寄存器之后，在执行指令的过程中，指令寄存器的内容不允许发生变化，以保证实现指令的全部功能。</p></li><li><p><strong>存储器数据寄存器</strong></p><p>存储器数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一条指令或一个数据字时，也暂时将它们存放在存储器数据寄存器中。</p></li><li><p><strong>存储器地址寄存器</strong></p><p>存储器地址寄存器用来保存当前CPU 所访问的主存单元的地址。由于主存和 CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到主存的读/写操作完成为止。 当CPU和主存进行信息交换，无论是 CPU向主存存/取数据时，还是CPU从主存 中读出指令时，都要使用存储器地址寄存器和数据寄存器。</p></li><li><p><strong>状态标志寄存器</strong></p><p>状态标志寄存器用来存放<strong>程序状态字</strong>的。 程序状态字的各位表征程序和机器运行的状态，是参与控制程序执行的重要依据之一。</p><p>它主要包括两部分内容：</p><ul><li><strong>状态标志</strong>，如： 进位标志（C）、结果为零标志（Z）等， 大多数指令的执行将会影响到这些标志位</li><li><strong>控制标志</strong>，如：中断标志、陷阱标志等。</li></ul><p>8086的状态标志寄存器共16位，包括九个标志位，其中六个为状态标志，三个为控制标志</p><p><img src=https://i.ibb.co/CtpTNXK/image-20221112170314433.png loading=lazy alt=image-20221112170314433></p></li></ul></li></ul><p><img src=https://i.ibb.co/rmYNtrQ/image-20221112170506055.png loading=lazy alt=image-20221112170506055></p><h4 id=功能>功能</h4><p>控制器的主要功能：</p><p>⑴从主存中取出一条指令，并指出下一条指 令在主存中的位置。</p><p>⑵对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</p><p>⑶指挥并控制CPU、主存和输入/输出设备之间的数据流动方向。</p><p>运算器的主要功能有：</p><p>⑴执行所有的算术运算</p><p>⑵执行所有的逻辑运算，并进行逻辑测试</p><h4 id=主要技术参数>主要技术参数</h4><p>（不关注，但要注意参数，公式 ）</p><ul><li><p><strong>字长</strong></p><p>单位时间内同时处理的二进 制数据的位数。</p><p>CPU按照其处理信息的字长可以分为：8位CPU、16位CPU、32位CPU以及64位CPU等。</p></li><li><p><strong>内部工作频率</strong></p><p>又称为内频或<strong>主频</strong>，它是衡量 CPU速度的重要参数。CPU的主频表示在CPU内<strong>数字脉冲信号震荡的速度</strong>，与CPU实际的运算能 力并没有直接关系。因此主频仅是CPU性能表现的一个方面，而不代表CPU的整体性能。</p><p>内部时钟频率的倒数是<strong>时钟周期</strong>，这是 CPU中最小的时间元素。每个动作至少需要一个时钟周期</p></li><li><p><strong>外部工作频率</strong></p><p>CPU除了主频之外，还有另一种工作频率，称为外部工作频率，它是由<strong>主板</strong>为CPU提供的<strong>基准时钟频率</strong></p><p>早期， CPU 的内频就<strong>等于</strong>外频。</p><p>例如： 80486DX-33 的内频是33MHz ，它的外频也是33MHz。也就是说，80486DX-33以33MHz的速度在内部进行运算，也同样以33MHz的速度<strong>与外界沟通</strong>。</p><p>目前，CPU的内频越来越高，相比之下主存的速度还很缓慢，如果外频设计得跟内频同步， 则主存都将无法跟上CPU的速度。所以现在外频 跟内频不再只是一比一的同步关系，从而出现了 所谓的<strong>内部倍频技术</strong>，导致了“倍频”的出现。 内频、外频和倍频三者之间的关系是：</p><p>内频=外频×倍频</p><p>理论上倍频是从1.5一直到无限，以0.5为一个间隔单位</p></li><li><p><strong>前端总线频率</strong></p><p>前端总线（Front Side Bus），通常用FSB表示，它是<strong>CPU和外界交换数据的最主要通道</strong>，主要连接主存、显卡等数据吞吐率高的部件，因此前端总线的数据传输能力对计算机整体性能作用 很大。</p><p>在Pentium 4出现之前，前端总线频率与外频是相同的，因此往往直接称前端总线频率为外 频。随着计算机技术的发展，需要前端总线频率高于外频，因此采用了<strong>QDR</strong>（Quad Date Rate） 技术或者其他类似的技术，使得前端总线频率成为外频的2倍、4倍甚至更高</p></li><li><p><strong>QPI数据传输速率</strong>（less important）</p><p>取代FSB的<strong>基于包传输的高速点到点连接技术</strong> QPI（快速通道互联）。 QPI抛弃了FSB易混淆的单位MHz，而使用GT/s 、MT/s，明确的表示总线<strong>实际</strong>的数据传输速率，而不是时钟频率。T/s即transfers per second，表示每秒数据传输的次数。QPI总线采用的是2:1比率，即<strong>实际的数据传输速率两倍于实际的总线时钟频率</strong>。 QPI 的时钟频率基于2.4 GHz、3.2 GHz，则QPI的数据传输速率为4.8GT/s、6.4GT/s，如时钟频率2.4GHz 的QPI的数据传输速率是2.4 GHz × 2 = 4.8 GT/s。</p><p>一个基本的QPI数据包是<strong>80bit</strong>，需要<strong>四次传输</strong>完成每次整个数据包的传输，每次传输的20位数据中 ，有16位为有效数据，其余4位用于循环冗余校验。 由于QPI是双向的，在发送的同时也可以接收另一端传输来的数据，这样，每个<strong>QPI总线总带宽=每秒传输次数（即QPI速率）×每次传输的有效数据（即 16bit/8=2Byte）×双向</strong>。所以QPI速率为4.8GT/s的总带宽=4.8 GT/s × 2Byte × 2 = 19.2 GB/s，QPI速率为 6.4GT/s 的 总带宽= 6.4 GT/s × 2 Byte × 2 = 25.6 GB/s。不难发现，目前的QPI比以前最宽最快的FSB，还要快一倍。</p></li><li><p><strong>片内Cache的容量</strong></p><p>片内Cache又称CPU Cache，它的容量和工作速率对提高计算机的速度起着关键的作用。CPU Cache可以分为L1 Cache、L2 Cache，部分高端 CPU还具有L3 Cache。</p><ul><li><p>L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存。一般来说，一级缓存可以分为</p><ul><li>一级数据缓存（Data Cache，D-Cache）</li><li>一级指令缓存（Instruction Cache，I-Cache）</li></ul><p>大多数CPU的一级数据缓存和一级指令缓存具有 相同的容量，例如D-Cache和I-Cache各为64KB， 总容量为128KB</p></li><li><p>L2 Cache是影响CPU性能的关键因素之一 ，在CPU核心不变化的情况下，增加L2 Cache的容量能使性能大幅度提高，而同一核心CPU的高低端之分往往也是在L2 Cache上有差异。目前CPU的L2 Cache一般为1MB， 最大可达4MB～8MB。</p></li><li><p>L3 Cache是为读取L2 Cache后未命中的数据设计的—种缓存，在拥有L3 Cache的CPU中，只有约5%的数据需要从内存中调用，这进一步提高了CPU的效率。L3 Cache的容量一般从8MB～16MB不等。</p></li></ul></li><li><p><strong>工作电压</strong></p><p>CPU正常工作所需的电压</p></li><li><p><strong>地址总线宽度</strong></p><p>决定了<strong>CPU可以访问的最大的物理地址空间</strong>，简单地说就是CPU到底能够使用多大容量的主存。</p><p>例如，Pentium 有32位地址线，可寻址的最大容量为$2^{32}$＝ 4096MB（4GB），Itantium有44位地址线， 可寻址的最大容量为$2^{44}$＝16TB。</p></li><li><p><strong>数据总线宽度</strong></p><p>决定了CPU与外部Cache、 主存以及输入输出设备之间进行<strong>一次数据传输的信息量</strong>。</p><p>如果数据总线为32位，每次最多可以读写主存中的32位；</p><p>如果数据总线为 64位，每次最多可以读写主存中的64位。</p><p>数据总线和地址总线是互相独立的，数据总线宽度指明了芯片的信息传递能力，而地址总线宽度说明了芯片可以访问多少个主存单元</p></li><li><p><strong>制造工艺</strong></p><p>线宽是指<strong>芯片内电路与电路之间的距离</strong>，可以用<strong>线宽</strong>来描述制造工艺。线宽越小，意味着芯片上包括的晶体管数目越多。</p><p>Pentium Ⅱ的线宽是0.35μm，晶体管数达 到7.5兆个；</p><p>Pentium Ⅲ的线宽是0.25μm， 晶体管数达到9.5兆个；</p><p>Pentium 4的线宽是 0.18μm，晶体管数达到42兆个。</p><p>近年来线宽已由0.15μm、0.13μm、90nm、65nm一 直发展到目前主流的45nm和32nm，而 22nm的制造工艺将是新一代CPU的发展目标。</p></li></ul><h3 id=控制器的组成和实现>控制器的组成和实现</h3><p>计算机系统的<strong>指挥中心</strong>，它把运算器、存储器、输入/输出设备等部件组成一个有机的整体，然后根据指令的要求指挥全机的工作。</p><p><img src=https://i.ibb.co/NFdZdXx/image-20221112180224898.png loading=lazy alt=image-20221112180224898></p><p><strong>组成</strong></p><ul><li><p>指令部件</p><p>完成取指令并分析指令</p><ul><li><p>程序计数器（PC）</p></li><li><p>指令寄存器（IR）</p></li><li><p>指令译码器（ID）</p><p>指令译码器又称<strong>操作码译码器</strong>或<strong>指令功能分析解释器</strong>。暂存在指令寄存器中的指令只有在其操作码部分经过译码之后才能识别出这是一条什么样的指令，并产生相应的控制信号提供给 微操作信号发生器</p></li><li><p>地址形成部件</p><p>根据指令的不同寻址方式，用来形成操作数的有效地址，在微、小型机中，一般不设专门的地址形成部件，而是利用运算器来进行有效地址的计算。</p></li></ul></li><li><p>时序部件</p><p>能产生一定的时序信号，以保证机器的各功能部件有节奏地进行信息传送、加工及信息存储</p><ul><li><p>脉冲源</p><p>用来产生具有一定频率和宽度的时钟脉冲信号，为整个机器提供基准信号</p></li><li><p>启停控制逻辑</p><p>根据计算机的需要，可靠地<strong>开放或封锁</strong>脉冲，控制时序信号的发生或停止，实现对整个机器的正确启动或停止。启停控制逻辑保证启动时输出的第一个脉冲和停止时输出的最后一 个脉冲都是完整的脉冲。</p></li><li><p>节拍信号发生器</p><p>又称脉冲分配器。脉冲源产生的脉冲信号，经过节拍信号发生器后产生出各个机器周期中的节拍信号， 用以控制计算机完成每一步微操作。</p></li></ul></li><li><p>微操作信号发生器</p><p>一条指令的取出和执行可以分解成很多最基本的操作，这种<strong>最基本的不可再分割的操作</strong>称为微操作。微操作信号发生器也称为控制单元（CU）。不同的机器指令具有不同的微操作序列</p></li><li><p>中断控制逻辑</p><p>控制中断处理的硬件逻辑</p></li></ul><p><strong>硬件实现方法</strong></p><p>控制器的输入是<strong>机器指令代码</strong>，输出是<strong>微操作控制信号</strong>，因此微操作信号发生器是控制器的<strong>核心</strong>。根据产生微操作控制信号的方式不同，控制器可分为3种，它们的根本区别在于微操作信号发生器的实现方法不同，而控制器中的其它部分基本上是大同小异的。</p><p><img src=https://i.ibb.co/SmPy32C/image-20221112192755100.png loading=lazy alt=image-20221112192755100></p><ul><li><p>组合逻辑型</p><p>称为<strong>常规控制器</strong>或<strong>硬布线控制器</strong>，它是采用<strong>组合逻辑</strong>技术来实现的， 其微操作序列形成部件是由<strong>门电路</strong>组成的复杂树形网络。 组合逻辑控制器的最大优点是<strong>速度快</strong>， 但是微操作信号发生器的结构不规整，使得设计、调试、维修较困难，难以实现设计自动化。一旦微操作信号发生器构成之后，要想<strong>增加新的控制功能是不可能</strong>的。</p></li><li><p>存储逻辑型</p><p>这种控制器称为<strong>微程序控制器</strong>，它是采用<strong>存储逻辑</strong>来实现的，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器） 中，微操作控制信号由微指令产生。 微程序控制器的设计思想和组合逻辑设计思想截然不同。它具有<strong>设计规整、调试、 维修以及更改、扩充指令方便</strong>的优点，易于实现自动化设计，已成为当前控制器的主流。 但是，由于它增加了一级控制存储器，所以<strong>指令执行速度比组合逻辑控制器慢</strong></p></li><li><p>组合逻辑和存储逻辑结合型</p><p>这种控制器称为<strong>PLA控制器</strong>，它是组合逻辑技术和存储逻辑技术结合的产物， 它克服了两者的缺点，是一种较有前途的方法</p></li></ul><h3 id=时序系统与控制方式>时序系统与控制方式</h3><h4 id=时序系统>时序系统</h4><p><strong>机器周期</strong></p><p>机器周期通常又称<strong>CPU周期</strong>，通常把一条指令划分为若干个机器周期（取指令，分析指令，执行指令），每个机器周期完成一个基本操作。</p><p><strong>指令周期</strong></p><p>取指令、分析指令到执行完该指令所需的全部时间。</p><p>由于各种指令的操作功能不同，有的简单，有的复杂， 因此各种指令的指令周期不尽相同。</p><p>指令周期＝i×机器周期</p><p>通常，每个机器周期都有一个与之对应的<strong>周期状态触发器</strong>。机器运行在不同的机器周期，其对应的周期状态触发器被置 “1”，显然，在机器运行的任何时刻只能建立一个周期状态，因此，有一个且仅有一个触发器被置“1” 。</p><p><strong>节拍</strong></p><p>在一个机器周期内，要完成若干个微操作。这些微操作有的可以同时执行，有的需要按先后次序串行执行。因而需要把一个机器周期分为若干个相等的时间段， 每一个时间段对应一个电位信号，称为<strong>节拍电位信号</strong>。 节拍的宽度取决于CPU完成一次基本操作的时间</p><p>由于不同的机器周期内需要完成的微操作内容和个数是不同的，因此，不同机器周期内所需要的节拍数也不相同。</p><p>节拍的选取一般有以下几种方法:</p><ul><li><p>统一节拍法</p><p>以最复杂的机器周期为准定出节拍数， 每一节拍时间的长短也以最繁的微操作作为标准。这种方法采用统一的、具有相等时间间隔和相同数目的节拍，使得所有的机器周期长度都是相等的，因此称为<strong>定长CPU周期</strong></p></li><li><p>分散节拍法</p><p>按照机器周期的实际需要安排节拍数， 需要多少节拍，就发出多少节拍，这样可以避免浪费，提高时间利用率。由于各机器周期长度不同，又称为<strong>不定长CPU周期</strong></p></li><li><p>延长节拍法</p><p>在照顾多数机器周期要求的情况下， 选取适当的节拍数，作为<strong>基本节拍</strong>，如果在某个机器周期内统一的节拍数无法完成该周期的全部微操作，则可以延长节拍。</p></li><li><p>时钟周期插入 （目前方法）</p><p>在一些微型机中，时序信号中不设置节拍，而直接使用时钟周期信号。一个机器周期中含有若干个时钟周期，时钟周期的数目取决于机器周期内完成微操作的多少及相应功能部件的速度。一个机器周期的基本时钟周期数确定之后，还可以不断插入<strong>等待时钟周期</strong>。</p></li></ul><p><strong>工作脉冲</strong></p><p>在节拍中执行的有些操作需要同步定时脉冲，为此，在一个节拍内常常设置<strong>一个或几个</strong>工作脉冲，作为各种同步脉冲的来源。工作脉冲的宽度只占节拍电位宽度的1/n，并处于节拍的末尾，只要能保证所有触发器都可靠、稳定地翻转就可以了。 在只设置机器周期和时钟周期的微型机中，一般不再设置工作脉冲，因为时钟周期既可以作为电位信号，其前后沿又可以作为脉冲触发信号</p><p><strong>多级时序系统</strong></p><p>小型机中常采用<strong>机器周期、节拍、工作脉冲</strong>三级时序系统。每个机器周期M中包括若干节拍，每个节拍内有一个脉冲。 在机器周期间、节拍电位间、工作脉冲间既不允许有重叠交叉，也不允许有空隙， 应该是一个接一个的准确连接。</p><h4 id=控制方式>控制方式</h4><ul><li><p>同步控制方式</p><p>即<strong>固定时序控制方式</strong>， 各项操作都由统一的时序信号控制，在每个机器周期中产生统一数目的节拍电位和工作脉冲。由于不同的指令，操作时间长短不一致，同步控制方式应以最复杂指令 的操作时间作为统一的时间间隔标准。这种控制方式设计<strong>简单</strong>，容易实现， 但是对于许多简单指令来说会有较多的空闲时间，造成较大数量的<strong>时间浪费</strong>，从而影响了指令的执行速度。 在同步控制方式中，各指令所需的时序由控制器统一发出，所有微操作都与时钟同步，所以又称为集中控制方式或中央控制方式</p></li><li><p>异步控制方式</p><p>即<strong>可变时序控制方式</strong>。 各项操作不采用统一的时序信号控制，而根据指令或部件的具体情况决定，需要多少时间，就占用多少时间。 异步控制采用不同时序，没有时间上的浪费，因而提高了机器的效率，但是控制比较<strong>复杂</strong>由于这种控制方式没有统一的时钟， 而是由各功能部件本身产生各自的时序信 号自我控制，故又称为分散控制方式或局部控制方式。</p></li><li><p>联合控制方式</p><p>同步控制和异步控制相结合。实际上现代计算机中几乎没有完全采用同步或完全采用异步的控制方式，大多数是采用联合控制方式。</p><p>通常的设计思想是：在功能部件内部采用同步方式或以同步方式为主的控制方式，在功能部件之间采用异步方式。</p></li></ul><h4 id=指令执行过程>指令执行过程</h4><p>一条指令执行过程可以分为三个阶段： 取指令阶段、分析取数阶段和执行阶段。</p><ul><li><p>取指令阶段</p><p>将现行指令从主存中取出来并送至指令寄存器中去。</p><p>具体的操作为：</p><ul><li><p>(PC)→MAR</p><p>将程序计数器（PC）中的内容送至存储器地址寄存器（MAR），并送地址总线（AB）</p></li><li><p>Read</p><p>由控制单元（ CU ）经控制总线（CB）向主存发读命令</p></li><li><p>M(MAR) →MDR</p><p>从主存中取出的指令通过数据总线 （DB）送到存储器数据寄存器（MDR）。</p></li><li><p>(MDR)→IR</p><p>将MDR的内容送至指令寄存器（IR） 中</p></li><li><p>(PC)＋1→PC</p></li></ul><p>将PC的内容递增，为取下一条指令 做好准备</p><p>以上这些操作对任何一条指令来说都是必须要执行的操作，所以称为<strong>公共操作</strong></p></li><li><p>分析取数阶段</p><p>取出指令后，机器立即进入分析指令阶段，指令译码器ID可识别和区分不同的指令类型及各种获取操作数的方法。由于各条指令功能不同，寻址方式也不同，所以分析取数阶段的操作是各不相同的</p></li><li><p>执行阶段</p><p>执行阶段完成指令规定的各种操作， 形成稳定的运算结果，并将其存储起来</p></li></ul><h4 id=指令的微操作序列>指令的微操作序列</h4><p>控制器在实现一条指令的功能时，总要把每条指令分解成为<strong>一系列时间上先后有序的最基本、最简单的微操作</strong>，即微操作序列。微操作序列是与CPU的<strong>内部数据通路</strong>密切相关的，不同的数据通路就有不同的微操作序列</p><h3 id=微程序控制原理>微程序控制原理</h3><p>微程序设计技术的实质是<strong>将程序设计技术和存储技术相结合</strong>，即用程序设计的思想方法来组织操作控制逻辑，将微操作控制信号按一定规则进行信息编码（代码化），形成<strong>控制字（微指令）</strong>，再把这些微指令按时间先后排列起来，存放在一个<strong>只读存储器</strong>中</p><p><strong>微操作</strong></p><p>计算机中<strong>最基本的、不可再分解</strong>的操作</p><p>一条机器指令可以分解成一个微操作序列</p><p><strong>微命令</strong></p><p>控制计算机各部件<strong>完成某个基本微操作</strong>的命令。</p><p>微命令与微操作<strong>一一对应</strong>，微命令是微操作的控制信号，微操作是微命令的操作过程。</p><p>微命令有<strong>兼容性和互斥性</strong>之分，兼容性微命令是指那些可以同时产生，共同完成某一些微操作的微命令；而互斥性微命令是指在机器中不允许同时出现的微命令。</p><p><strong>微指令</strong></p><p>控制存储器中的一个单元的内容，即<strong>控制字</strong>，它是若干个微命令的<strong>集合</strong></p><p>一条微指令通常至少包含两大部分信息：</p><ul><li>操作控制字段，又称<strong>微操作码字段</strong>， 用以产生某一步操作所需的各微操作控制信号。</li><li>顺序控制字段，又称<strong>微地址码字段</strong>， 用以控制产生下一条要执行的微指令地址。</li></ul><p>微指令有<strong>垂直型和水平型</strong>之分，垂直型微指令接近于机器指令的格式，每条微指令只能完成一个基本操作。水平型微指令则具有良好的并行性，每条微指令可以完成较多的基本操作</p><p><strong>微地址</strong></p><p>存放控制字的控制存储器的单元地址就称为微地址。</p><p><strong>微周期</strong></p><p>从控制存储器中读取一条微指令并执行相应的微命令所需的全部时间称为微周期</p><p><strong>微程序</strong></p><p>一系列<strong>微指令的有序集合</strong>就是微程序</p><p>一条机器指令对应于一段微程序</p><p>微程序和程序是两个不同的概念。微程序是由微指令组成的，它用于描述机器指令，实际上是机器指令的实时解释器，它是由计算机的设计者事先编制好并存放在控制存储器中的。对于程序员来说，计算机系统中微程序一级的结构和功能是<strong>透明</strong>的。而程序则最终由机器指令组成，它是由软件设计人员事先编制好并存放在主存或辅存中的。</p><p>所以说，微程序控制的计算机涉及到两个层次：一个是机器语言或汇编语言程序员所看到的<strong>传统机器层</strong>，包括：机器指令、 工作程序、主存储器；另一个是机器设计者看到的<strong>微程序层</strong>，包括：微指令、微程序和控制存储器</p><p><img src=https://i.ibb.co/rkGtD4D/image-20221113092507970.png loading=lazy alt=image-20221113092507970></p><h4 id=微指令编码法>微指令编码法</h4><p>微指令编码法指的就是<strong>操作控制字段的编码方法</strong>。</p><ul><li><p><strong>直接控制法（不译码法）</strong></p><p>操作控制字段中的各位分别可以直接控制计算机，不需要进行译码。操作控制字段的每一个独立的二进制位代表一个微命令，该位为“1”表示这个微命令有效， 为“0”表示这个微命令无效。每个微命令对应并控制数据通路中的一个微操作</p><ul><li>结构简单，并行性强，操作速度快，</li><li>微指令字太长，若微命令的总数为N个，则微指令字的操作控制字段就要有N位。另外，在N个微命令中，有许多是互斥的，不允许并行操作，将它们安排在一条微指令中是毫无意义的，只会使信息的利用率下降。</li></ul></li><li><p><strong>最短编码法</strong></p><p>使得微指令字最短。这种方法将所有的微命令统一编码，<strong>每条微指令只定义一个微命令</strong>。</p><p>若微命令的总数为N， 操作控制字段的长度为L，则：$L\ge log_2N$</p></li><li><p><strong>字段编码法</strong></p><p>（<strong>仅要求</strong>字段直接编码法）</p><p>这种方法将操作控制字段分为若干个小段，每段内采用最短编码法，段与段之间采用直接控制法。这种方法又可进一步分为字段直接编码法和字段间接编码法。</p><ul><li><p><strong>字段直接编码法</strong></p><p>各字段都可以独立地定义本字段的微命 令，而和其他字段无关，因此又称为显式编 码或单重定义编码方法</p><p><img src=https://i.ibb.co/TrJbhGp/image-20221113100036118.png loading=lazy alt=image-20221113100036118></p></li><li><p><strong>字段间接编码法</strong></p></li></ul></li></ul><p><strong>操作控制字段的分段原则</strong></p><ul><li>把互斥性的微命令分在同一段内， 兼容性的微命令分在不同段内。这样不仅有助于<strong>提高信息的利用率，缩短微指令字长</strong>，而且有助于<strong>充分利用硬件所具有的并行性</strong>，加快执行的速度</li><li>与数据通路结构相适应</li><li>每个小段中包含的信息位不能太多， 否则将增加译码线路的复杂性和译码时间</li><li>一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此当某字段的长度为三位时，最多只能表示七个互斥的微命令，通常用000表示不操作</li></ul><h4 id=微程序控制器的组成和工作过程>微程序控制器的组成和工作过程</h4><p><img src=https://i.ibb.co/Y3cqdMr/image-20221113102442743.png loading=lazy alt=image-20221113102442743></p><ul><li><p>微地址形成部件</p><p>产生初始微地址和后继微地址。</p></li><li><p>微地址寄存器（ $\mu$MAR ）</p><p>接受微地址形成部件送来的微地址， 为在CM中读取微指令作准备。</p></li><li><p>控制存储器（CM）</p><p>微程序控制器的<strong>核心</strong>部件，用来存放微程序。</p></li><li><p>微指令寄存器（$\mu$IR ）</p><p>存放从CM取出的正在执行的微指令</p></li></ul><p>微程序控制器的工作过程实际上就是在微程序控制器的控制下，计算机执行机器指令的过程。</p><ul><li><p>执行取指令公操作。</p><p>取指令的公共操作通常由一段取指微程序来完成，这 个取指微程序也可能仅由一条微指令组成。 具体的执行是：在机器开始运行时，自动将取指微程序的入口微地址送$\mu$MAR，并从CM中读出相应的微指令送入$\mu$IR。微指令的操作控制字段产生有关的微命令，用来控制实现取机器指令的公共操作。</p><p><strong>取指微程序的入口地址一般为CM的0号单元</strong>， 当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器IR中了</p></li><li><p>由机器指令的操作码字段通过<strong>微地址形成部件</strong>产生出该机器指令所对应的微程序的入口地址，并送入$\mu$MAR。</p></li><li><p>从CM中逐条取出对应的微指令并执行</p></li><li><p>执行完对应于一条机器指令的一段微程序后又回到取指微程序的入口地址，继续第⑴步，以完成取下条机器指令的公共操作。</p></li></ul><p>以上是一条机器指令的执行过程，如此周而复始，直到整个程序执行完毕为止。</p><p><strong>入口地址形成</strong></p><p>当公用的取指微程序从主存中取出机器指令之后， 由<strong>机器指令的操作码字段指出各段微程序的入口地址（初始微地址）</strong>。这是一种多分支 （或多路转移）的情况，由机器指令的操作码转换成初始微地址的方式主要有三种。</p><ul><li><p>一级功能转换</p><p>如果机器指令操作码字段的位数和位置固定，可以直接使操作码与入口地址码的部分位<strong>相对应</strong>。</p></li><li><p>二级功能转换</p><p>当同类机器指令的操作码字段的位数和位置固定，而不同类机器指令的操作码的位数和位置不固定时，就不能再采用一级功能转换的方法。所谓二级功能转换是指第一次<strong>先按指令类型标志转移</strong>，以区分出指令属于哪一类，如：是单操作数指令， 还是双操作数指令等。因为每一类机器指令中操作码字段的位数和位置是固定的， 所以第二次即可按操作码区分出具体是哪条指令，以便找出相应微程序的入口微地址。</p></li><li><p>通过PLA电路实现功能转换</p><p>当机器指令的操作码位数和位置<strong>都不固定</strong>时，可以采用PLA电路将每条机器指令的操作码翻译成对应的微程序入口地址。这种方法对于变长度、变位置的操作码显得更有效，而且转换速度较快</p></li></ul><p><strong>后续地址形成</strong></p><p>后继微地址的形成方法对微程序编制的灵活性影响很大，它主要有两大基本类型：</p><ul><li><p><strong>增量方式</strong></p><p>这种方式和机器指令的控制方式很类似， 它也有顺序执行、转移和转子之分。顺序执行时后继微地址就是现行微地址加上一个增量（通常为1）；转移或转子时，由微指令的顺序控制字段产生转移微地址。因此，在微程序控制器中应当有一个微程序计数器 （ $\mu$PC），为了降低成本，一般情况下都是将微地址寄存器$\mu$MAR改为具有计数功能的寄存器，以代替$\mu$PC</p></li><li><p>断定方式</p><p>断定方式的后继微地址可由微程序设计者指定，或者根据微指令所规定的测试结果直接决定后继微地址的全部或部分值。 这是一种直接给定与测试断定相结合的方式，其顺序控制字段一般由两部分组成： 非测试段和测试段。</p><ul><li><p>非测试段，可由设计者指定，一般是微地址的高位部分，用来指定后继微地址在CM中的某个区域内。</p></li><li><p>测试段，根据有关状态的测试结果确定其地址值，一般对应微地址的低位部分。这相当于在指定区域内断定具体的分支。所依据的测试状态可能是指定的开关状态、指令操作码、状态字等。</p><p>测试段如果只有一位，则微地址将产生两个分支，若有两位，则最多可产生四个分支，依此类推，测试段为n位最多可产生$2^n$个分支</p></li></ul></li></ul><h4 id=微程序设计>微程序设计</h4><p><strong>水平型微指令及水平型微程序设计</strong></p><p>水平型微指令是指<strong>一次能定义并能并行执行多个微命令的微指令</strong>。它的并行操作能力强，效率高，灵活性强，执行一条机器指令所需微指令的数目少，执行时间短；但微指令字较长，增加了控存的横向容量，同时微指令和机器指令的差别很大， 设计者只有熟悉了数据通路，才有可能编制出理想的微程序，一般用户不易掌握。</p><p><strong>垂直型微指令和垂直型微程序设计</strong></p><p>垂直型微指令是指<strong>一次只能执行一个微命令的微指令</strong>。它的并行操作能力差， 一般只能实现一个微操作，控制一、二个信息传送通路，效率低，执行一条机器指令所需的微指令数目多，执行时间长；但是微指令与机器指令很相似，所以容易掌握和利用，编程比较简单，不必过多地了解数据通路的细节，且微指令字较短。</p><h3 id=指令流水线>指令流水线</h3><p>（不做计算方面要求，仅考察概念）</p><p><strong>流水线基本原理</strong></p><p>流水线技术是一种<strong>显著提高指令执行速度与效率</strong>的技术。方法是：指令取指完成后，不等该指令执行完毕即可取下一条指令。 如果把一条指令的解释过程进一步细分，例如 ，把分析、执行两个过程分成<strong>取指FI、译码DI、计算操作数地址CO、取操作数FO、执行指令EI和写回寄存器WO</strong>六个子过程，并用六个子部件分别处理这六个子过程。</p><p>这样只需在上一指令的第一子过程处理完毕进入第二子过程处理时，在第一子部件中就开始对第二条指令的第一子过程进行处理。随着时间推移，这种重叠操作最后可达到六个子部件同时对六条指令的子过程进行操作。</p><p><strong>影响流水线性能的因素</strong></p><p>在流水线中会出现三种相关，影响流水线的畅通流动：</p><ul><li><p><strong>结构相关</strong></p><p>当多条指令进入流水线后，硬件资源满足不了指令重叠执行的要求时产生。</p></li><li><p><strong>数据相关</strong></p><p>指令在流水线中重叠执行时，当后继指令需要用到前面指令的执行结果时发生。</p></li><li><p><strong>控制相关</strong></p><p>当流水线遇到分支指令和其他改变PC值的指令时引起</p></li></ul><p><strong>性能</strong></p><p>通常用吞吐率、加速比和效率3项指标来衡量</p><ul><li><p><strong>吞吐率</strong></p><p>单位时间内流水线所完成指令或输出结果的数量</p></li><li><p><strong>加速比</strong></p><p>m 段的流水线的速度与等功能的非流水线的速度之比</p></li><li><p><strong>效率</strong></p><p>指流水线中各功能段的利用率，由于流水线有建立时间和排空时间，因此各功能段的设备不可能一直处于工作状态</p></li></ul><p><strong>超标量</strong></p><p>通过重复设置多个功能部件，并让这些功能部件同时工作起来来提高指令的执行速度在超标量的处理器结构中，整数和浮点数运算 、装入、存储以及条件转移等普通操作指令可以同时启动并独立执行。 超标量流水CPU是指集成了多条流水线结构的 CPU，当流水线满载时，每个时钟周期可以完成一条以上的指令。</p><p><strong>流水线分类</strong></p><p>流水线按功能可分成单功能流水线和多功能流水线两种。</p><ul><li>单功能流水线只完成一种功能。如浮点加法或乘法流水线。</li><li>多功能流水线则可完成多种功能，它允许在不同时间，甚至同一时间内在流水线内连接不同功能段的子集来实现不同功能</li></ul><p>流水线按工作方式可分为静态流水线和动态流水线两种。</p><ul><li>在静态流水线中，同一时间内它只能以一种功能方式工作。它可以是单功能的，也可以是多功能的。当是多功能流水线时，则从一种功能方式变为另一种功能方式时，必须先排空流水线，然后为另一种功能设置初始条件后方可使用。显然，不希望这种功能的转换频繁的发生，否则将严重影响流水线的处理效率。</li><li>动态流水线则允许在同一时间内将不同的功能段连接成不同的功能子集（前提条件是功能部件的使用不发生冲突），以完成不同的运算功能。 显然，动态流水线必是多功能流水线，而单功能流水线则必是静态的。</li></ul><h2 id=chapter-7-总线>Chapter 7 总线</h2><p>总线是一组能为多个部件服务的<strong>公共信息传送线路</strong>，它能分时地发送与接收各部件的信息。</p><p>总线结构的优点：</p><ul><li>大大减少信息传送线的数目</li><li>提高计算机扩充内存及外部设备的<strong>灵活性</strong></li></ul><h3 id=分类>分类</h3><p>按<strong>功能层次</strong>分：</p><ul><li>片内总线：CPU内部的总线</li><li>系统总线：计算机各部件之间的信息传输线<ul><li>数据总线：双向，与机器字长、存储字长有关</li><li>地址总线：单向，与存储地址、 I/O地址有关</li><li>控制总线：部分出部分入，控制器控制所有部件</li></ul></li><li>通信总线：用于计算机系统之间、计算机系统与其他系统（如控制仪表、移动通信等）之间的通信</li></ul><p>按<strong>数据线的多少</strong>分为：</p><ul><li>并行总线：含有多条数据线的总线，可以实现一个数据的<strong>多位同时</strong>传输。</li><li>串行总线：含有一条双向数据线或两条单向数据线的总线，可以实现一个数据的<strong>各位按照一定的速度和顺序</strong>依次传输。</li></ul><h3 id=结构>结构</h3><p><strong>单总线结构</strong></p><p>单总线结构是将CPU、主存、I/O设备（通过 I/O接口）都挂在<strong>一组总线</strong>上。</p><p>CPU与主存、CPU与外设之间可以直接进行信息交换，主存与外设、外设与外设之间也可以直接进行信息交换，而不需经过CPU的干预。</p><p><img src=https://i.ibb.co/2KHkLPB/image-20221204201645457.png loading=lazy alt=image-20221204201645457></p><p><strong>双总线结构</strong>
这种结构保持了单总线结构的优点，又在CPU和主存之间专门设置了一组存储总线。
优缺点：由于CPU和主存之间需要频繁地交换信息，采用专用的存储总线后，存取速度将大大提高，同时也减轻了系统总线的负担，但是硬件的代价随之有所增加</p><p><img src=https://i.ibb.co/XfH4x4L/image-20221204201724861.png loading=lazy alt=image-20221204201724861></p><p><strong>三总线结构</strong>
在双总线系统上增加I/O总线</p><p><img src=https://i.ibb.co/pJFGNJC/image-20221204201809361.png loading=lazy alt=image-20221204201809361></p><h3 id=性能指标>性能指标</h3><ul><li><p>总线宽度：数据总线的根数</p></li><li><p>总线带宽：数据传输率</p><p>总线带宽定义为总线的最大数据传输率，即每秒传输的字节数。在同步通信中，总线的带宽与总线时钟密不可分，总线时钟频率的高低决定了总线带宽的大小。
$$
B=W\times\frac{F}{N}
$$
其中，W为数据总线宽度，通常以字节为单位；F为总线的时钟频率；N为完成一次数据传送所用的时钟周期数。</p><p><img src=https://i.ibb.co/9Nk8Bs7/image-20221204202328695.png loading=lazy alt=image-20221204202328695></p></li><li><p>时钟同步/异步：总线上的数据与时钟同步的称为同步总线，与时钟不同步的称为异步总线</p></li><li><p>信号线数：地址总线、数据总线和控制总线三种总线数的总和。</p></li></ul><h3 id=总线仲裁>总线仲裁</h3><p>由于总线上连接着多个部件，何时由哪个部件发送信息，如何定时，如何防止信息丢失，如何避免多个设备同时发送，如何规定接收部件等一系列问题都需要总线控制器统一管理。
为了保证同一时刻只有一个申请者使用总线，总线控制机构中设置有总线判优和仲裁控制逻辑。
总线判优按其仲裁控制机构的设置可分为<strong>集中式控制</strong>和<strong>分布式控制</strong>两种。</p><h4 id=集中式>集中式</h4><p><strong>链式查询方式</strong>
链式查询方式的总线控制器使用三根控制线与所有部件和设备相连。
三根控制线是：</p><ul><li>总线请求（BR）：该线有效，表示至少有一个部件或设备要求使用总线</li><li>总线忙（BS）：该线有效，表示总线正在被某部件或设备使用</li><li>总线批准（BG）：该线有效，表示总线控制器响应总线请求</li></ul><p>当一个或多个设备同时发出总线使用请求信号BR时，中央仲裁器发出的总线授权信号BG沿着菊花链串行的从一个设备依次传送到下一个设备，到达离出发点最近的发出总线请求的设备之后就不再往下传。</p><p><strong>计数器定时查询方式</strong>
计数定时查询方式的总线上的每个部件可以通过公共的BR 线发出请求，总线控制器收到请求之后，在BS为“0”的情况下， 让计数器开始计数，定时地查询各个部件以确定是谁发出的请求。
当查询线上的计数值与发出请求的部件号一致时，该部件就使BS线置“1”，获得了总线使用权，并中止计数查询，直至该部件完成数据传送之后，撤消BS信号。</p><p><strong>独立请求方式</strong>
在独立请求方式中， 每一个共享总线的部件均有一对控制线：总线请求BRi和总线批准BGi。当某个部件请求使用总线时，便发出BRi，总线控制器中有一排队电路，根据一定的优先次序决定首先响应哪个部件的请求BRi，然后给该部件送回批准信号BGi。
独立请求方式的优点是响应时间快，然而这是以增加控制线数和硬件电路为代价的。此方式对优先次序的控制也是相当灵活的，它可以预先固定，也可以通过程序来改变优先次序。</p><h4 id=分布式>分布式</h4><p>同集中式仲裁相比，分布式仲裁不需要中央仲裁器，而是让各个主设备功能模块都有自己的仲裁号和仲裁电路。
需要使用总线时，各个设备的功能模块将自己唯一的仲裁号发送到共享的总线上，各自的仲裁电路再将从仲裁总线上获得的仲裁号和自己的仲裁号相对比，获胜的仲裁号将保留在仲裁总线上，相应设备的总线请求获得响应。
多个设备提出总线请求时，一般采用优先级或公平策略进行仲裁</p><h2 id=chapter-8-外部设备>Chapter 8 外部设备</h2><p>除主机以外，而又围绕着主机而设置的各种硬件装置叫做外部设备或外围设备</p><ul><li>输入/输出设备
从计算机的角度出发，向计算机输入信息的外部设备称为输入设备；接受计算机输出信息的外部设备称为输出设备。</li><li>辅助存储器
辅助存储器即<strong>外存储器</strong>，它是指主机以外的存储装置，又称为后援存储器。</li><li>终端设备
终端设备由输入设备、输出设备和终端控制器组成，通常通过通信线路与主机相连。终端设备具有向计算机输入和接收计算机输出的能力，具有与通信线路连接的通信控制能力，有些还具有一定的数据处理能力。</li><li>过程控制设备
模/数、数/模转换设备均是过程控制设备，有关的检测设备也属于过程控制设备。</li></ul><h3 id=磁介质存储器>磁介质存储器</h3><h4 id=读写过程>读写过程</h4><ul><li>磁记录介质
在磁介质存储器中，信息是记录在一薄层磁性材料的表面上，这个薄层称为<strong>磁层</strong>。磁层与所附着的载体被称为记录介质或记录媒体。</li><li>磁头
磁头是磁记录设备的关键部件之一，它是一种<strong>电磁转换元件</strong>。写磁头实现把电脉冲表示的二进制代码转换成磁记录介质上的磁化状态，即电－磁转换；读磁头实现把磁记录介质上的磁化状态转换成电脉冲，即磁－电转换。在读写过程中，记录介质与磁头之间相对运动，一般是记录介质运动而磁头不动</li></ul><p><strong>写入过程</strong></p><p>在写磁头线圈中通以一定方向的写电流，于是在磁头下方的一个局部区域被磁化，形成一个<strong>磁化单元</strong>或称记录单元。当这部分介质移出磁头作用区后，仍将留下足够强的剩磁。在写磁头中通以正、负两个不同方向的写电流，就会产生<strong>两种不同的剩磁状态</strong>，正好对应二进制信息的“1”和“0”。</p><p><strong>读出过程</strong></p><p><img src=https://i.ibb.co/02wbd6J/image-20221206143903702.png loading=lazy alt=image-20221206143903702></p><p><strong>读出过程</strong></p><p>读出时，读出线圈不外加电流。当某一磁化单元运动到读磁头下方时，使得磁头中流过的磁通有很大的变化，于是在读出线圈两端产生<strong>感应电动势</strong>e。感应电动势e经放大、检波、限幅、整形和选通后，获得符合要求的信号。</p><p><img src=https://i.ibb.co/JFjmB8G/image-20221206144108024.png loading=lazy alt=image-20221206144108024></p><h4 id=技术指标-1>技术指标</h4><ul><li><p><strong>记录密度</strong>
记录密度是指磁介质存储器单位长度或单位面积磁层表面所能存储的二进制信息量。通常以<strong>道密度</strong>和<strong>位密度</strong>表示，也可用两者的乘积<strong>面密度</strong>来表示。</p><ul><li>道密度
道密度又叫<strong>横向密度</strong>，是指垂直于磁道方向上单位长度中的磁道数目，道密度 的单位是道/英寸（TPI）或道/毫米（TPM）。磁道指的是磁头写入磁场在记录介质表面上形成的磁化轨迹。</li><li>位密度
位密度又叫<strong>纵向密度</strong>，是指沿磁道方向上单位长度中所能记录的二进制信息的位数，位密度的单位为位/英寸（bpi）或位/毫（bpm）。</li></ul></li><li><p><strong>存储容量</strong>
存储容量是指整个磁介质存储器所能存储的二进制信息的<strong>总量</strong>，一般用位或字节为单位表示，它与存储介质尺寸和记录密度直接相关。磁介质存储器的存储容量有<strong>非格式化容量和格式化容量</strong>两种指标。非格式化容
量是指磁记录表面上可全部利用的磁化单元数；格式化容量是指用户实际可以使用的存储容量。格式化容量一般约为非格式化容量的60～80％左右。</p></li><li><p><strong>平均存取时间</strong>
当磁头接到读/写命令，从原来的位置移动到指定位置，并完成读/写操作的时间叫存取时间。对于磁盘存储器来说，存取时间主要包括4部分：</p><p>第一部分是指磁头从原先位置移动到目的磁道所需要的时间，称为定位时间或寻道时间；</p><p>第二部分是指在到达目的磁道以后，等待被访问的记录块旋转到磁头下方的等待时间，称为旋转时间或等待时间；</p><p>第三部分是信息的读写操作时间，也称为传输时间；</p><p>最后是磁盘控制器的开销。</p><p>由于寻找不同磁道和等待不同记录块所花的时间不同，所以通常取它们的平均值。传输时间和控制器的开销相对平均寻道时间$T_s$和平均等待时间$T_w$来说要小得多，所以磁盘的平均存取时间Ta约等于
$$
T_a=T_s+T_w=\frac{T_{smax}+T_{smin}}{2}+\frac{T_{wmax}+T_{wmin}}{2}
$$</p></li><li><p><strong>数据传送率</strong>
磁介质存储器在单位时间内向主机传送数据的位数或字节数，称为数据传送率Dr ，单位为位/秒或字节/秒。</p></li><li><p><strong>误码率</strong>
误码率是衡量磁介质存储器出错概率的参数，它等于读出的出错信息位数和读出总的信息位数之比。</p></li></ul><h4 id=数字磁记录方式>数字磁记录方式</h4><p>为了提高磁介质存储器的性能，扩大存储容量，加快存取速度，除了要不断改善磁头和记录介质的电磁性能和机械性能之外，选用高性能的数字磁记录方式对提高记录密度和可靠性也是很重要的。磁记录方式是一种<strong>编码方式</strong>，即按照某种规律将一连串的二进制数字信息变换成记录介质上相应磁化翻转形式</p><h5 id=直接记录方式>直接记录方式</h5><p>当记录密度较低时，可以不编码，直接按记录信息的“0”、“1”排序记录。</p><ul><li><p>归零制（RZ）
记录“1”时，磁头线圈中通以正向脉冲电流；记录“0”时，通以反向脉冲电流。由于脉冲电流均要回到零，故称为归零制。
归零制的两个脉冲之间有一段间隔没有电流，相应的这段磁层<strong>未被磁化</strong></p></li><li><p>不归零制（NRZ）</p><p>记录“1”时，磁头线圈以中通正向电流；记录“0”时，通以反向电流。磁头中电流不回到零。如果记录的相邻两位信息相同（即连续录“1”或“0”）时，写电流方向不变；只有当记录的相邻两位信息不相同（即“0”和“1”交替）时，写电流才改变方向，所以又称为异码变化或“见变就翻”的不归零制</p></li><li><p>不归零－1制（NRZ-1）
这是一种改进的不归零制，记录“1”时，磁头线圈中写电流改变方向，使磁层磁化翻转；而记录“0”时，写电流方向维持不变，保持原来的磁化状态，所以称之为见“1”就翻的不归零制。</p></li></ul><p><img src=https://i.ibb.co/4MM36tY/image-20221206145927157.png loading=lazy alt=image-20221206145927157></p><p>以上各种记录方式，目前已很少应用，但不归零制是编码方式的基础，无论哪一种编码方式，只要数据序列变换成记录序列之后，均按照NRZ-1制规则记录到磁层上。</p><h5 id=按位编码记录方式>按位编码记录方式</h5><ul><li><p><strong>调相制（PE）</strong>
调相制又称<strong>相位编码</strong>方式，它采用0°和180°相位的不同分别示“1”或“0”。它的编码规则是：</p><ul><li>记录“1”时，写电流在位周期中间由负变正；</li><li>记录 “0” 时，写电流在位周期中间由正变负。</li><li>当连续出现两个或两个以上 “1” 或 “0” 时，为了维持上述原则，在位周期的边界上也要翻转一次。</li></ul><p>这种记录方式常用于磁带机中。</p></li><li><p><strong>调频制（FM）</strong>
调频制是根据写电流的频率来区分记录“1”或“0”的。</p><ul><li>记录“1”时，写电流在位周期中间和边界各改变一次方向；</li><li>记录“0”时，写电流仅在位周期边界改变一次方向。</li></ul><p>因此，记录“1”的磁化翻转频率为记录“0”时的两倍，故又称<strong>倍频制</strong>。若以T0表示位周期，则调频制的磁化翻转间距为<strong>0.5T0和T0</strong>。</p></li><li><p><strong>改进的调频制（MFM）</strong>
MFM制是在FM制基础上改进的一种记录方式，又称为延迟调制码或密勒码。其编码规则为：</p><ul><li>记录“1”时，写电流在位周期中间改变方向；</li><li>记录独立的一个“0”，写电流不改变方向；</li><li>记录连续的两个“0”，写电流在位周期边界改变方向。</li></ul><p>改进的调频制的磁化翻转间距有三种：T0、1.5T0、2T0 ，对应于三种不同的频率，所以又称为<strong>三频制</strong>。</p></li><li><p><strong>改进的改进型调频制（$M^2FM$）</strong>
$M^2FM$制的编码规则为：</p><ul><li>记录“1”时，写电流在位周期中间改变方向；</li><li>记录独立的一个“0”，写电流不改变方向；</li><li>记录连续的两个“0”，写电流在位周期边界处改变方向，产生磁化翻转；</li><li>记录连续两个以上的“0”，写电流在前两个“0”的位周期边界处改变方向，以后每隔两个“0”的位周期边界处，写电流再改变一次方向，产生翻转翻转。</li></ul><p>改进的改进型调频制的磁化翻转间距有四种：<strong>T0、1.5T0、2T0、2.5T0</strong>，对应于四种不同的频率，所以又称为<strong>四频制</strong>。</p></li></ul><p><img src=https://i.ibb.co/m8G1FX0/image-20221206150853521.png loading=lazy alt=image-20221206150853521></p><h3 id=磁盘存储器>磁盘存储器</h3><h4 id=基本结构>基本结构</h4><p>硬盘存储器的硬件包括<strong>硬盘控制器（适配器）、硬盘驱动器以及连接电缆</strong>。硬盘控制器对硬盘进行管理，并在主机和硬盘之间传送数据。硬盘驱动器内有多个盘片，它们被叠装在主轴上，构成一个盘组，每个盘片的两面都可用作记录面。</p><p><img src=https://i.ibb.co/6mh7PB7/image-20221206152104103.png loading=lazy alt=image-20221206152104103></p><p>硬盘存储器可分为<strong>温彻斯特盘</strong>和<strong>非温彻斯特盘</strong>两类。温彻斯特盘的主要特点是磁头、盘片、磁头定位机构、主轴，甚至连读/写驱动电路等都被<strong>密</strong>封在一个盘盒内，构成一个头－盘组合体，这个组合体不可随意拆卸，它的防尘性能好，可靠性高，对使用环境要求不高。而非温式磁盘的磁头和盘片等不是密封的，因此要求有超净使用环境。</p><p>硬盘存储器还可分为<strong>固定头硬盘</strong>和<strong>活动头硬盘</strong>两类。固定头硬盘机中，每个磁道对应一个磁头，省去了磁头找磁道的时间，存取速度快。但由于磁头太多，使磁盘的道密度不可能很高。移动头硬盘机中，每个盘面上只有一个读写头，安装在读写臂上，当需要在不同磁道上读写时，要驱动读写臂沿盘面作径向移动。由于增加了寻道时间，所以其存取时间比固定头硬盘机要长。</p><p><strong>硬盘驱动器</strong></p><ul><li><strong>磁头</strong>
接触启停式浮动磁头是指读/写操作时磁头<strong>浮空</strong>，不与盘面记录区相接触，以免划伤记录区。但在启动前和停止后，磁头将仍与盘面接触。具体的做法是：在盘面记录区与轴心之间有一段空白区，被当作启停区或着陆区。未启动前及停止后，磁头停在启停区，与盘面接触。当盘片旋转并达到额定转速时，气垫浮力使磁头浮起并达到所需的浮动高度，然后将磁头向外移至0号磁道，准备寻道</li><li><strong>磁头定位系统</strong><ul><li>步进电机定位机构
整个定位机构是开环控制。根据现行磁道号与目的的磁道号之差，求得步进脉冲数，每发一个步进脉冲，脉冲移动一个道距。步进电机定位机构的结构紧凑、控制简单，但定位精度比较低。</li><li>音圈电机定位机构
音圈电机可以直接驱动磁头作直线运动，整个定位系统是一个带有速度和位置反馈的闭环调节自动控制系统，其特点是寻道速度快，定位精度高。</li></ul></li></ul><h4 id=信息分布>信息分布</h4><p>在硬盘中信息分布呈如下层次：<strong>记录面、圆柱面、磁道、扇区</strong></p><p><strong>记录面</strong>
硬盘驱动器中可有多个盘片（数量为1~20片），每个盘片有两个记录面，<strong>每个记录面对应一个磁头</strong></p><p><strong>磁道</strong>
在读/写时，磁头固定不动，盘片高速旋转，磁化区构成一个<strong>闭合圆环</strong>，称为磁道。在盘面上，一条条磁道形成一组同心圆，最外圈的磁道为0号，往内则磁道号逐步增加。（每个盘片可有500~2500条磁道）。</p><p><strong>圆柱面</strong>
在一个盘组中，各记录面上相同编号（位置）的诸磁道构成一个圆柱面。例如，某驱动器有4片8面，则8个0号磁道构成0号圆柱面，8个1号磁道构成1号圆柱面。硬盘的圆柱面数等于一个记录面上的磁道数，圆柱面号即对应的磁道号。引入圆柱面的概念是为了<strong>提高硬盘的存储速度</strong>。</p><p><strong>扇区</strong>
通常将<strong>一条磁道划分为若干个段</strong>，每个段称为一个扇区或扇段，每个扇区存放一个定长信息块（如512个字节）。一条磁道划分多少扇区，每个扇区可存放多少字节，一般由操作系统决定。磁道上的扇区编号从1号开始</p><p><strong>磁盘地址</strong></p><p>主机向磁盘控制器送出有关寻址信息，磁盘地址一般表示为：
<strong>驱动器号、圆柱面（磁道）号、记录面（磁头）号、扇区号</strong></p><h4 id=技术参数>技术参数</h4><p><strong>硬盘容量</strong>
硬盘容量当然是越大越好。</p><p><strong>主轴转速</strong>
从理论上来说，转速越快，硬盘的速度越快。</p><p><strong>道密度</strong>
硬盘驱动器在介质上的道密度可达38 000TPI或更高</p><p><strong>平均存取时间</strong>
平均存取时间近似等于平均寻道时间和平均等待时间之和。
<strong>缓存</strong>
缓存存在的目的是为了解决硬盘内部与接口数据之间速度不匹配的问题，它可以提高硬盘的读写速度。</p><p><strong>数据传输率</strong>
硬盘的数据传输率分为<strong>内部</strong>数据传输率和<strong>外部</strong>数据传输率。内部数据传输率主要依赖于硬盘的旋转速度，因硬盘的品牌及型号不同而有着较大的差异。外部数据传输率指的是系统总线与硬盘缓冲区之间的数据传输率，外部数据传输率与硬盘接口类型和缓存大小有关。</p><p><strong>非格式化容量＝最大位密度×最内圈 磁道周长×总磁道数</strong></p><p>新的磁盘在使用之前需先进行格式化， 格式化实际上就是在磁盘上划分记录区， 写入各种标志信息和地址信息，这些信息占用了磁盘的存储空间，故格式化之后的有效存储容量要小于非格式化容量。</p><p><strong>格式化容量＝每道扇区数×扇区容量 ×总磁道数</strong></p><p><img src=https://i.ibb.co/x2TrJzb/image-20221206154700439.png loading=lazy alt=image-20221206154700439></p><p><img src=https://i.ibb.co/7tDWfTR/image-20221206154713482.png loading=lazy alt=image-20221206154713482></p><h4 id=分区域记录>分区域记录</h4><p>传统硬盘驱动器的每个磁道上记录的扇区数是相同的，因而存储的信息量也是相同的，这意味着在磁盘上位密度是变化的。因为内圈磁道的周长短，外圈磁道的周长长，所以<strong>内圈磁道的位密度高，外圈磁道的位密度低</strong>，最内圈磁道的位密度（最大位密度）决定了磁盘驱动器的容量。
又因为每个磁道记录的信息量及转速是相同的，所以它们的数据传送率也是相同的。</p><p>由于外圈磁道比内圈磁道更长一些，但存储的信息量却相同，所以外圈磁道上明显地存在着浪费。
采用分区域记录（等位密度）技术可以增加硬盘驱动器的容量。由于外圈磁道有更长的周长，所以<strong>外层磁道要比内层磁道包含更多的扇区</strong>，即外圈磁道上保存的信息比内圈磁道多。</p><p>分区域记录的另一个影响是数据传输率随磁头所处的区域而变化。分区域驱动器还是以恒定速度旋转，可是，<strong>由于外层区域每磁道有更多的扇区，所以数据传输速度要更快一些</strong>。这就是当今驱动器标注最小和最大连续传输速率的原因，因为传输速率取决于磁头读/写的位置。分区域记录技术的使用，大大地提高了硬盘利用率，与采用每磁道固定扇区的硬盘比较，使驱动器增加了20～50％的硬盘容量。实际上，现在所有的IDE和SCSI都采用分区域记录</p><p><img src=https://i.ibb.co/Zh2Srzh/image-20221206155354263.png loading=lazy alt=image-20221206155354263></p><h2 id=chapter-9-输入输出系统>Chapter 9 输入输出系统</h2><h3 id=输入输出接口>输入输出接口</h3><p>主机和外设的连接方式有<strong>辐射型连接、总线型连接</strong>等。输入/输出接口（I/O接口）是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。
主机和外设各自具有自己的工作特点，它们在信息形式和工作速度上具有很大的差异，接口正是为了<strong>解决这些差异</strong>而设置的。</p><p>主机和外设之间需要交换的信息有：</p><ol><li><p><strong>数据信息</strong>
这类信息可以是通过输入设备送到计算机的<strong>输入数据</strong>，也可以是经过计算机运算处理和加工后，送到输出设备的<strong>结果数据</strong>。传送可以是并行的，也可以是串行的。</p></li><li><p><strong>控制信息</strong>
这是<strong>CPU对外设的控制信息或管理命令</strong>，如外设的启动和停止控制、 输入或输出操作的指定、工作方式的选择、中断功能的允许和禁止等</p></li><li><p><strong>状态信息</strong>
这类信息用来标志<strong>外设的工作状态</strong>，比如，输入设备数据准备好标志，输出设备忙闲标志等。CPU在必要时可通过对它的查询来决定下一步的操作。</p></li><li><p><strong>联络信息</strong>
这是主机和外设间工作的<strong>时间配合信息</strong>，它与主机和外设间的信息交换方式密切相关。通过联络信息可以决定不同工作速度的外设和主机之间交换信息的最佳时刻，以保证整个计算机系统能统一协调地工作。</p></li><li><p><strong>外设识别信息</strong>
这是<strong>I/O寻址</strong>的信息，使CPU能从众多的外设中寻找出与自己进行信息交换的唯一外部设备</p></li></ol><h4 id=功能-1>功能</h4><ul><li><p>实现主机和外设的<strong>通信联络控制</strong></p><p>接口中的同步控制电路用来解决主机与外设的时间配合问题。</p></li><li><p>进行<strong>地址译码</strong>和设备选择</p><p>当CPU送来选择外设的地址码后，接口必须对地址进行译码以产生设备选择信息，使主机能和指定外设交换信息</p></li><li><p>实现<strong>数据缓冲</strong></p><p>在接口电路中，一般设置有一个或几个数据缓冲寄存器，用于数据的暂存，以避免因速度不一致而丢失数据。在传送过程中，先将数据送入数据缓冲寄存器中，然后再送到输出设备或主机中去。</p></li><li><p>数据<strong>格式的变换</strong></p><p>在输入或输出操作过程中，为了满足主机或外设的各自要求，接口电路中必须具有完成各类数据相互转换的功能。</p></li><li><p>传递<strong>控制命令和状态信息</strong>
当CPU要启动某一外设时，通过接口中的控制命令寄存器向外设发出启动命令；当外设准备就绪时，则有状态信息送回接口中的状态寄存器，为CPU 提供反馈信息，告诉CPU，I/O设备已经具备和CPU交换数据的条件。当外设向CPU提出中断请求和DMA请求时，CPU也有相应的响应信号反馈给外设。</p></li></ul><h4 id=组成>组成</h4><p>接口中要分别传送数据信息、控制信息和状态信息，数据信息、控制信息和状态信息都通过数据总线来传送。大多数计算机都把I/O设备的状态信息视为输入数据，而把控制信息看成输出数据，并在接口中分设各自相应的寄存器，赋以不同的端口地址，各种信息分时地使用数据总线传送到各自的寄存器中。</p><p><img src=https://i.ibb.co/HLZ4MmP/image-20221206190919174.png loading=lazy alt=image-20221206190919174></p><p><strong>端口</strong>是指接口电路中可以进行读/写的寄存器，若干个端口加上相应的控制逻辑电路组成接口。</p><p>通常，一个接口中包含有<strong>数据端口、控制端口和状态端口</strong>。存放数据信息的寄存器称为数据端口，存放控制命令的端口称为命令端口，存放状态信息的寄存器称为状态端口。CPU通过输入指令可以从有关端口中读出信息，通过输出指令可以把信息写入有关端口。对状态端口只进行输入操作，将设备状态标志送到CPU 中去；对命令端口只进行输出操作，CPU将向外设发送各种控制命令。因此，在有的接口电路中状态信息和控制信息共用一个寄存器，称之为设备的控制状态寄存器。</p><h4 id=类型>类型</h4><p><strong>按数据传送方式分类</strong>
有串行接口和并行接口。这里所说的数据传送方式指的是外设和接口一侧的传送方式，而在主机和接口一侧，数据总是并行传送的。</p><p><strong>按主机访问I/O设备的控制方式分类</strong>
可分为程序查询式接口、中断接口、DMA接口、通道接口等。</p><p><strong>按功能选择的灵活性分类</strong>
有可编程接口和不可编程接口。</p><p><strong>按通用性分类</strong>
有通用接口和专用接口。</p><p><strong>按输入/输出的信号分类</strong>
有数字接口和模拟接口。</p><p><strong>按应用来分类</strong>
①运行辅助接口。
② 用户交互接口。
③ 传感接口。
④ 控制接口。</p><h4 id=外设的识别与端口寻址>外设的识别与端口寻址</h4><p>外设识别是通过地址总线和接口电路中的<strong>外设识别电路</strong>来实现的，I/O端口地址就是主机与外设直接通信的地址，CPU可以通过端口发送命令、读取状态和传送数据。
<strong>端口地址编址方式</strong>
I/O端口编址方式有两种：一种是<strong>I/O映射方式</strong>，即把I/O端口地址与主存单元地址分别进行独立的编址；另一种是<strong>存储器映射方式</strong>，即把端口地址与主存单元地址统一编址。</p><ul><li><p><strong>独立编址</strong>
主存地址空间和I/O端口地址空间是相对独立的，分别单独编址。比如，在8086中，其主存地址范围是从00000H～FFFFFH连续的1MB，其I/O端口的地址范围从0000H～ FFFFH，它们互相独立，互不影响。CPU访问主存时，由主存读/写控制线控制；访问外设时，由I/O读/写控制线控制，所以在指令系统中必须设置专门的I/O指令。当CPU使用
I/O指令时，其指令的地址字段直接或间接的指示出端口地址。</p></li><li><p><strong>统一编址</strong>
I/O端口地址和主存单元的地址是统一编址的，把I/O接口中的端口作为主存单元一样进行访问，不设置专门的I/O指令。
每个外设至少有两个寄存器：<strong>控制状态寄存器和数据缓冲寄存器</strong>，外设寄存器的地址码是连续的。在PDP-11中，把主存的高4KB地址空间留给外设接口寄存器和CPU内部寄存器使用，这4KB存储空间不允许用户再存放其他内容</p></li></ul><h4 id=信息传送控制方式>信息传送控制方式</h4><p><strong>程序查询方式</strong>
程序查询方式是一种程序直接控制方式，这是主机与外设间进行信息交换的最简单方式，<strong>输入和输出完全是通过CPU执行程序来完成的</strong>。
这种方式控制简单，但外设和主机不能同时工作，各外设之间也不能同时工作，系统效率很低，因此，仅适用于外设的数目不多，对I/O处理的实时要求不那么高，CPU的操作任务比较单一，并不很忙的情况</p><p><strong>程序中断方式</strong>
外设在作好输入/输出准备时，向主机发中断请求，<strong>主机接到请求后就暂时中止原来执行的程序，转去执行中断服务程序对外部请求进行处理</strong>，在中断处理完毕后返回原来的程序继续执行。
程序中断不仅允许主机和外设同时并行工作，并且允许一台主机管理多台外设。但是完成一次程序中断需要许多辅助操作，可能使CPU应接不暇；对于一些高速外设，可能会造成信息丢失，因此，它主要适用于中、低速外设</p><p><strong>直接存储器存取（DMA）方式</strong>
DMA方式是在主存储器和外部设备之间开辟<strong>直接的数据通路</strong>，可以进行基本上不需要CPU介入的主存和外设之间的信息传送，这样不仅能保证CPU的高效率，而且能满足高速外设的需要。
DMA方式只能进行简单的数据传送操作，在数据块传送的起始和结束时还需CPU及中断系统进行预处理和后处理。</p><p><strong>I/O通道控制方式</strong>
通道是一个具有<strong>特殊功能的处理器</strong>，它能独立地执行通道程序，产生相应的控制信号，实现对外设的统一管理和外设与主存之间的数据传送。但它不是一个完全独立的处理机，它要在CPU的I/O指令指挥下才能启动、停止或改变工作状态，是从属于CPU的一个专用处理器。
一个通道执行输入/输出过程全部由通道按照通道程序自行处理，不论交换信息多少，<strong>只打扰CPU两次（启动和停止时）</strong>。</p><h3 id=程序查询方式>程序查询方式</h3><p>由CPU执行一段输入、输出程序来实现主存与外设之间的数据传送方式，叫做程序直接控制方式。根据外设的不同性质，这种传送方式又可分为无<strong>条件传送</strong>和<strong>程序查询方式</strong>两种。</p><p>在无条件传送方式中，I/O接口总是准备好接收主机的输出数据，或总是准备好向主机输入的数据，因而CPU无需查询外设的工作状态，而<strong>默认外设始终处于准备就绪状态</strong>。</p><p>许多外设的工作状态是很难事先预知的，为了保证数据传送的正确进行，就要求CPU在程序中查询外设的工作状态，如果外设尚未准备就绪，CPU就<strong>等待</strong>，只有外设已作好准备，CPU才能执行I/O指令，这就是程序查询方式。</p><h4 id=工作流程>工作流程</h4><ul><li><p>预置传送参数
在传送数据之前，由CPU执行一段程序，预置传送参数。传送参数包括存取数据的主存缓冲区<strong>首地址</strong>和传送数据的<strong>个数</strong>。</p></li><li><p>向I/O接口发命令字
当CPU选中某台外设时，执行输出指令向I/O接口发出命令字，启动外设，为接收数据或发送数据的操作做准备。</p></li><li><p>从I/O接口取回状态字
CPU执行输入指令，从I/O接口中<strong>取回状态字并进行测试</strong>，判断数据传送是否可以进行。</p></li><li><p>查询外设标志
CPU不断查询状态标志，如果外设没有准备就绪，CPU就踏步进行等待，一直到这个外设准备就绪，并发出“准备就绪”信号为止。</p></li><li><p>传送数据
只有外设准备好，才能实现主机与外设间的一次数据传送。输入时，CPU执行输入指令，从I/O接口的数据缓冲寄存器中接收数据；输出时，CPU执行输出指令，将数据写入I/O接口的数据缓冲寄存器。</p></li><li><p>修改传送参数
每进行一次数据传送，需要修改传送参数，其中包括主存缓冲区地址加1，传送个数减1。</p></li><li><p>判断传送是否结束</p><p>如果传送个数不为0，则转第3步，继续传送，直到传送结束为止。</p></li></ul><h3 id=程序中断方式>程序中断方式</h3><h4 id=中断>中断</h4><p><strong>自愿中断和强迫中断</strong>
自愿中断又称程序自中断，它不是随机产生的中断，而是在程序中安排的有关指令，这些指令可以使机器进入中断处理的过程，如：指令系统中的软件中断指令等。
强迫中断是随机产生的中断，不是程序中事先安排好的。当这种中断产生后，由中断系统强迫计算机中止现行程序并转入中断服务程序。</p><p><strong>程序中断和简单中断</strong>
程序中断就是我们前面提到的中断，主机在响应中断请求后，通过执行一段中断服务程序来处理更紧迫的任务。
简单中断就是外设与主存间直接进行信息交换的方法，即DMA方式。这种“中断”不去执行中断服务程序，故不破坏现行程序的状态。主机发现有简单中断请求（也就是DMA请求）时，将让出一个或几个存取周期供外设与主存交换信息，然后继续执行程序</p><p><strong>内中断和外中断</strong>
内中断是指由于CPU内部硬件或软件原因引起的中断。
外中断是指CPU以外的部件引起的中断。</p><p><strong>向量中断和非向量中断</strong>
向量中断是指那些中断服务程序的入口地址是由<strong>中断事件自己提供</strong>的中断。中断事件在提出中断请求的同时，通过硬件向主机提供中断服务程序入口地址，即向量地址。</p><p>非向量中断的中断事件不能直接提供中断服务程序的入口地址，而由<strong>CPU 查询</strong>之后得到。</p><p><strong>单重中断和多重中断</strong>
单重中断在CPU执行中断服务程序的过程中不能被再打断。
多重中断在执行某个中断服务程序的过程中，CPU 可去响应级别更高的中断请求，又称为中断嵌套。</p><h4 id=中断源>中断源</h4><p>中断源是指中断的来源，即任何引起计算机中断的事件</p><p>可采用具有存储功能的触发器来记录中断源，称为<strong>中断请求触发器</strong>。当某一个中断源有中断请求时，其相应的中断请求触发器置成“1”状态，此时，该中断源向CPU发出中断请求信号。</p><p>多个中断请求触发器构成一个<strong>中断请求寄存器</strong>，其中每一位对应一个中断源，中断请求寄存器的内容称为<strong>中断字或中断码</strong>，中断字中为“1”的位就表示对应的中断源有中断请求。</p><h4 id=中断请求信号>中断请求信号</h4><p>(1)独立请求线</p><p>每个中断源单独设置中断请求线，将中断请求信号直接送往CPU，这种方式的特点是CPU在接到中断请求的同时也就知道了中断源是谁，其中断服务程序的入口地址在哪里。
(2) 公共请求线</p><p>多个中断源共有一根公共请求线，这种方式的特点是在负载允许的情况下，中断源的数目可随意扩充，但CPU在接到中断请求后，必须通过<strong>软件或硬件的方法</strong>来识别中断源，然后再找出中断服务程序的入口地址。
(3) 二维结构
将中断请求线连成二维结构，<strong>同一优先级别的中断源， 采用一根公共的请求线</strong>，不同请求线上的中断源优先级别不同，这种方式综合了前两种方式的优点，在中断源较多的系统中常采用这种方式。</p><h4 id=中断优先级>中断优先级</h4><p>当多个中断源同时发出中断请求时，CPU在<strong>任何瞬间只能接受一个</strong>中断源的请求。通常，把全部中断源按中断的性质和处理的轻重缓急安排优先级，并进行排队。
确定中断优先级的原则是：对那些提出中断请求后需要立刻处理，否则就会造成<strong>严重后果</strong>的中断源规定最高的优先级；而对那些可以延迟响应和处理的中断源规定较低的优先级。如故障中断一般优先级较高，接着才是I/O设备中断。而在I/O设备中又可以根据各个设备的速度来决定优先级。</p><p>每个中断源均有一个为其服务的中断服务程序，每个中断服务程序都有与之对应的优先级别。另外，CPU正在执行的程序也有优先级。只有当某个中断源的优先级别高于CPU现在的优先级时，才能中止CPU执行现在的程序。</p><h5 id=软件判优法>软件判优法</h5><p>软件判优法，就是用程序来判别优先级，这是最简单的中断判优方法</p><p>当CPU接到中断请求信号后，就执行查询程序，逐个检测中断请求寄存器的各位状态，检测顺序是按优先级的大小排列的，<strong>最先检测的中断源具有最高的优先级，其次检测的中断源具有次高优先级，如此下去</strong>，最后检测的中断源具有最低的优先级。</p><p>显然，软件判优是与识别中断源结合在一起的，当查询到中断请求信号的发出者，也就是找到了中断源，程序立即可以转入对应的中断服务程序中去</p><h5 id=硬件判优电路>硬件判优电路</h5><p>采用硬件实现中断优先级判定可节省CPU时间，而且速度快，但是成本较高。根据中断请求信号的传送方式不同，有不同的优先排队电路，常见的有以下几种方案。</p><p>独立请求线的优先排队电路</p><p>公共请求线的优先排队电路</p><h4 id=中断响应>中断响应</h4><h5 id=cpu响应中断的条件><strong>CPU响应中断的条件</strong></h5><ul><li><p>CPU<strong>接收到</strong>中断请求信号
首先中断源要发出中断请求，同时C PU还要接收到这个中断请求信号。</p></li><li><p>CPU<strong>允许</strong>中断
CPU允许中断即开中断。CPU内部有一个中断允许触发器，只有当其被置位时，CPU才可能响应中断源的中断请求（中断开放）。如其被复位，CPU处于不可中断状态，即使中断源有中断请求，CPU也不响应（中断关闭）。</p></li><li><p>一条<strong>指令执行完毕</strong></p><p>一般情况下，CPU在一条指令执行完毕，且没有更紧迫的任务时才能响应中断请求。</p></li></ul><h5 id=中断隐指令>中断隐指令</h5><p>CPU响应中断之后，<strong>经过某些操作</strong>，转去执行中断服务程序。 这些操作是由硬件直接实现的，我们把它称为中断隐指令。</p><p>中断隐指令<strong>并不是指令系统中的一条真正的指令</strong>，它没有操作码，所以中断隐指令是一种不允许、也不可能为用户使用的特
殊指令。</p><p>其所完成的操作主要有：</p><ul><li><p>保存断点</p><p>将原来程序的断点（即程序计数器PC的内容）保存起来。</p></li><li><p>暂不允许中断</p><p>为了在用软件保护中断现场（即CPU的主要寄存器状态）时，不被新的中断所打断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确地执行下去。</p></li><li><p>引出中断服务程序</p><p>引出中断服务程序的实质就是取出<strong>中断服务程序的入口地址</strong>送程序计数器。</p></li></ul><h5 id=中断周期>中断周期</h5><ol><li>将特定地址“0”送至存储器地址寄存器，记作0→MAR；</li><li>将PC的内容（断点）送至MDR，记作(PC)→MDR；</li><li>向主存发写命令，启动存储器做写操作，记作Write；</li><li>将MDR的内容通过数据总线写入到MAR所指示的主存单元（ 0 号）中，记作MDR→M(MAR)；</li><li>向量地址形成部件的输出送至PC，为进入中断服务程序作准备，记作向量地址→PC；</li><li>关中断，将中断允许触发器清0，记作0→EINT。</li></ol><p>如果断点存入堆栈，只需将上述⑴改为堆栈指针SP→MAR。</p><h5 id=进入中断服务程序>进入中断服务程序</h5><p>识别中断源在于转入为该中断源专门设置的中断服务程序。
向量中断时，中断源向CPU发出中断请求信号之后，CPU经过一定的判优处理，若决定响应这个中断请求，则向中断源发出中断响应信号。中断源接到中断响应信号后就通过自己的向量地址发生器向CPU发送向量地址。</p><p><img src=https://i.ibb.co/68JxVgF/image-20221218161223158.png loading=lazy alt=image-20221218161223158></p><p>向量地址通常有两种情况：</p><p>(1) 向量地址是中断服务程序的入口地址如果向量地址就是中断服务程序的入口地址，则CPU 不需要再经过处理就可以进入相应的中断服务程序。</p><p>PC←8×NNN 转中断服务程序入口地址
由此可见，中断服务程序的入口地址
依次是00H、08H、10H、……、 38H。</p><p>(2) 向量地址是中断向量表的指针</p><p>如果向量地址是中断向量表的指针，则向量地址指向一个中断向量表，从中断向量表的相应单元中再取出中断服务程序的入口地址，此时中断源给出的向量地址是中断服务程序入口地址的地址。</p><h5 id=中断现场的保护和恢复>中断现场的保护和恢复</h5><p>中断现场指的是<strong>发生中断时CPU的主要状态</strong>，其中最重要的是<strong>断点</strong>，另外还有一些<strong>通用寄存器的状态</strong>。</p><p>之所以需要保护和恢复现场的原因是因为CPU要先后执行两个完全不同的程序（现行程序和中断服务程序），必须进行两种程序运行状态的转换。一般来说，在中断隐指令中，CPU硬件将自动保存断点，有些计算机还自动保存程序状态寄存器的内容。但是，在许多应用中，要保证中断返回后原来的程序能正确地继续运行，仅保存这一、二个寄存器的内容是不够的。</p><p>为此，在中断服务程序开始时，应由软件去保存那些硬件没有保存，而在中断服务程序中又可能用到的寄存器（如某些通用寄存器）的内容，在中断返回之前，这些内容还应该被恢复。</p><p>现代计算机一般都先采用硬件方法来自动快速的保护和恢复部分重要的现场，其余寄存器的内容再由软件完成保护和恢复，这种方法的硬件支持是堆栈。</p><h4 id=允许和禁止中断><strong>允许和禁止中断</strong></h4><p>允许中断还是禁止中断是用CPU中的中断允许触发器控制的，当中断允许触发器被置“1”，则允许中断，当中断允许触发器被置“0”，则禁止中断。
允许中断即开中断，下列情况时应开中断：
⑴ 在中断服务程序执行完毕，恢复中断现场之后；
⑵ 在多重中断的情况下，保护中断现场之后。</p><p>禁止中断即关中断，下列情况时应关中断：
⑴ 当响应某一级中断请求，不再允许被其他中断请求打断时；
⑵ 在中断服务程序的保护和恢复现场之前。</p><h4 id=中断屏蔽>中断屏蔽</h4><p>中断源发出中断请求之后，这个中断请求并<strong>不一定能真正送到CPU</strong>去，在有些情况下，可以用程序方式<strong>有选择地封锁部分中断</strong>，这就是中断屏蔽</p><p>如果给每个中断源都相应地配备一个<strong>中断屏蔽触发器MASK</strong>，则每个中断请求信号在送往判优电路之前，还要受到屏蔽触发器的控制。</p><p>当MASK=1，表示对应中断源的请求被屏蔽（封锁其中断源的请求），可见中断请求触发器和中断屏蔽触发器是<strong>成对出现</strong>的，只有当
INTRi=1（中断源有中断请求），MASKi=0（该级中断未被屏蔽），才允许对应的中断请求送往CPU。</p><p>在中断接口电路中，多个屏蔽触发器组成一个<strong>屏蔽寄存器</strong>，其内容称为<strong>屏蔽字或屏蔽码</strong>，由程序来设置。屏蔽字某一位的状态将成为本中断源能否真正发出中断请求信号的必要条件之一。</p><p>这样，就可实现CPU对中断处理的控制，使中断能在系统中合理协调地进行。</p><p>中断屏蔽寄存器的作用：</p><p>用程序设置的方法将屏蔽寄存器中的某一位置“1”，则对应的中断请求<strong>被封锁</strong>，无法去参加排队判优；若屏蔽寄存器中的某一位置“0”，才允许对应的中断请求送往CPU</p><h5 id=中断升级>中断升级</h5><p>中断屏蔽字的另一个作用是可以改变中断优先级，<strong>将原级别较低的中断源变成较高的级别</strong>，我们称之为中断升级。这实际上是一种动态改变优先级的方法。
这里所说的改变优先次序是指改变中断的处理次序。中断处理次序和中断响应次序是两个不同的概念，中断<strong>响应次序</strong>是由<strong>硬件</strong>排队电路决定的，无法改变。但是，中断<strong>处理次序</strong>是可以由<strong>屏蔽码</strong>来改变的，故把屏蔽码看成软排队器。中断处理次序可以不同于中断响应次序。</p><p><img src=https://i.ibb.co/SKGVg8X/image-20221218162712395.png loading=lazy alt=image-20221218162712395></p><p><strong>横着看</strong></p><p>第1级中断源的优先级别最高，它禁止本级和更低级的中断请求；第4级中断源的优先级别最低，它仅禁止本级的中断请求，而对其他高级的中断请求全部开放。</p><p><img src=https://i.ibb.co/pJdc8Sx/image-20221218162903731.png loading=lazy alt=image-20221218162903731></p><h4 id=中断全过程>中断全过程</h4><p>中断全过程是指从中断源发出中断请求开始，CPU响应这个请求，现行程序被中断，转至中断服务程序，直至中断服务程序执行完毕，CPU 再返回原来的程序继续执行的整个过程。
中断全过程分为五个阶段：
<strong>中断请求、中断判优、中断响应、中断处理、中断返回。</strong></p><p>其中中断处理就是<strong>执行中断服务程序</strong>，中断服务程序基本上由三部分组成，</p><p>第一部分为<strong>准备部分</strong>，其基本功能是保护现场，对于非向量中断方式则需要确定中断源，最后开放中断，允许更高级的中断请求打断低级的中断服务程序。</p><p>第二部分为<strong>处理部分</strong>，即真正执行为某个中断源服务的中断服务程序。</p><p>第三部分为<strong>结尾部分</strong>，首先要关中断，以防止在恢复现场过程中被新的中断打断，接着恢复现场，然后开放中断，以便返回原来的程序后可响应其它的中断请求</p><h3 id=dma方式>DMA方式</h3><h3 id=通道控制方式>通道控制方式</h3></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Jun 06, 2023 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/software-architecturenotes/><div class=article-details><h2 class=article-title>【Software Architecture】Notes</h2></div></a></article><article><a href=/p/computer-architecturenotes/><div class=article-details><h2 class=article-title>【Computer Architecture】Notes</h2></div></a></article><article><a href=/p/computer-networknotes/><div class=article-details><h2 class=article-title>【Computer Network】Notes</h2></div></a></article><article><a href=/p/computer-visionnotes/><div class=article-details><h2 class=article-title>【Computer Vision】Notes</h2></div></a></article><article><a href=/p/stanford-compilersnotes/><div class=article-details><h2 class=article-title>【Stanford Compilers】Notes</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>