<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="从文件中读取内容，向文件中写入内容，截短文件、合并文 件、压缩文件……，诸如此类的操作，称为文件存取操作， 主要使用“流（Stream）”来完成\n与文件操作相关的类，集中于java.io包中。\nJava 1.4中加入了一个New I/O API，提供了一些类完成文件和流操作。\nJava 7中又加入了一些新类型，称为NIO.2，NIO.2中最重要的是引入了Path和 AutoCloseable接口，还有一个Files类，它的静态方法封装了文件的常用操作。\nFile类 Java使用File类来统一操作文件和文件夹。\njava.io.File代表与平台无关的文件或目录。也就是说可以通过File类在Java程序中操作文件或目录； File类只能用来操作文件或目录（包括新建、删除、重命名文件和目录等操作），但不能用来访问文件中的内容； 如果需要访问文件中的内容，则需要使用输入/输出流。 RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。RandomAccessFile类支持“随机访问”方式，这里“随机”是指可以跳转到文件的任意位置处读写数据。 在访问一个文件的时候，不必把文件从头读到尾，而是希望像访问一个数据库一样“随心所欲”地访问一个文件的某个部分，这时使用类就是最佳选择。\u200e RandomAccessFile对象类有个位置指示器\u200e\u200e，指向当前读写处的位置，当前读写n个字节后，文件指示器将指向这n个字节后面的下一个字节处。 刚打开文件时，文件指示器指向文件的开头处，可以移动文件指示器到新的位置，随后的读写操作将从新的位置开始。 类在数据等长记录格式文件的随机（相对顺序而言）读取时有很大的优势，但该类仅限于操作文件，不能访问其他的I/O设备，如网络、内存映像等。\nIO Stream 分类 根据操作数据类型（能用记事本打开并能看到其中的字符内容的是文本文件，反之是二进制文件）\n字节流：二进制，以字节为单位\n字节流的两个基类 InputStream和OutputStream\n凡是以InputStream或OutputStream结尾的类型为字节流\n字符流：文本,以字符（2个字节）为单位\n字符流的两个基类 Reader和Writer\n凡是以Reader或Writer结尾的均为字符流\n区别\n字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法； 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节； 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据； 根据流向\n输入流 输出流 根据具体功能\n节点流：以从或向一个特定的地方（节点）读写数据。\n1、文件： FileInputStream 、FileOutputStream、 FileReader和 FileWriter 文件进行处理的节点流； 2、字符串： StringReader 和StringWriter 对字符串进行处理的节点流； 3、数组： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader和CharArrayWriter 对数组进行处理的节点流(对应的不再是文件，而是内存中的一个数组)； 4、管道： PipedInputStream 、PipedOutputStream 和PipedReaderPipedWriter对管道进行处理的节点流； 5、基类： InputStream、 OutputStream、 Reader和 Writer；\n处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。\n1、缓冲流：BufferedInputStream、 BufferedOutputStream、 BufferedReader和BufferedWriter 增加缓冲功能，避免频繁读写硬盘。 "><title>【Java】IO</title>
<link rel=canonical href=https://dyhes.github.io/p/javaio/><link rel=stylesheet href=/scss/style.min.6aa4d43a5cae1c51ef34b3f851ae7421f4b2f2d13827e2d975acbeb4f13c8710.css><meta property='og:title' content="【Java】IO"><meta property='og:description' content="从文件中读取内容，向文件中写入内容，截短文件、合并文 件、压缩文件……，诸如此类的操作，称为文件存取操作， 主要使用“流（Stream）”来完成\n与文件操作相关的类，集中于java.io包中。\nJava 1.4中加入了一个New I/O API，提供了一些类完成文件和流操作。\nJava 7中又加入了一些新类型，称为NIO.2，NIO.2中最重要的是引入了Path和 AutoCloseable接口，还有一个Files类，它的静态方法封装了文件的常用操作。\nFile类 Java使用File类来统一操作文件和文件夹。\njava.io.File代表与平台无关的文件或目录。也就是说可以通过File类在Java程序中操作文件或目录； File类只能用来操作文件或目录（包括新建、删除、重命名文件和目录等操作），但不能用来访问文件中的内容； 如果需要访问文件中的内容，则需要使用输入/输出流。 RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。RandomAccessFile类支持“随机访问”方式，这里“随机”是指可以跳转到文件的任意位置处读写数据。 在访问一个文件的时候，不必把文件从头读到尾，而是希望像访问一个数据库一样“随心所欲”地访问一个文件的某个部分，这时使用类就是最佳选择。\u200e RandomAccessFile对象类有个位置指示器\u200e\u200e，指向当前读写处的位置，当前读写n个字节后，文件指示器将指向这n个字节后面的下一个字节处。 刚打开文件时，文件指示器指向文件的开头处，可以移动文件指示器到新的位置，随后的读写操作将从新的位置开始。 类在数据等长记录格式文件的随机（相对顺序而言）读取时有很大的优势，但该类仅限于操作文件，不能访问其他的I/O设备，如网络、内存映像等。\nIO Stream 分类 根据操作数据类型（能用记事本打开并能看到其中的字符内容的是文本文件，反之是二进制文件）\n字节流：二进制，以字节为单位\n字节流的两个基类 InputStream和OutputStream\n凡是以InputStream或OutputStream结尾的类型为字节流\n字符流：文本,以字符（2个字节）为单位\n字符流的两个基类 Reader和Writer\n凡是以Reader或Writer结尾的均为字符流\n区别\n字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法； 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节； 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据； 根据流向\n输入流 输出流 根据具体功能\n节点流：以从或向一个特定的地方（节点）读写数据。\n1、文件： FileInputStream 、FileOutputStream、 FileReader和 FileWriter 文件进行处理的节点流； 2、字符串： StringReader 和StringWriter 对字符串进行处理的节点流； 3、数组： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader和CharArrayWriter 对数组进行处理的节点流(对应的不再是文件，而是内存中的一个数组)； 4、管道： PipedInputStream 、PipedOutputStream 和PipedReaderPipedWriter对管道进行处理的节点流； 5、基类： InputStream、 OutputStream、 Reader和 Writer；\n处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。\n1、缓冲流：BufferedInputStream、 BufferedOutputStream、 BufferedReader和BufferedWriter 增加缓冲功能，避免频繁读写硬盘。 "><meta property='og:url' content='https://dyhes.github.io/p/javaio/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Java'><meta property='article:published_time' content='2022-01-05T00:00:00+00:00'><meta property='article:modified_time' content='2022-01-05T00:00:00+00:00'><meta name=twitter:title content="【Java】IO"><meta name=twitter:description content="从文件中读取内容，向文件中写入内容，截短文件、合并文 件、压缩文件……，诸如此类的操作，称为文件存取操作， 主要使用“流（Stream）”来完成\n与文件操作相关的类，集中于java.io包中。\nJava 1.4中加入了一个New I/O API，提供了一些类完成文件和流操作。\nJava 7中又加入了一些新类型，称为NIO.2，NIO.2中最重要的是引入了Path和 AutoCloseable接口，还有一个Files类，它的静态方法封装了文件的常用操作。\nFile类 Java使用File类来统一操作文件和文件夹。\njava.io.File代表与平台无关的文件或目录。也就是说可以通过File类在Java程序中操作文件或目录； File类只能用来操作文件或目录（包括新建、删除、重命名文件和目录等操作），但不能用来访问文件中的内容； 如果需要访问文件中的内容，则需要使用输入/输出流。 RandomAccessFile（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。RandomAccessFile类支持“随机访问”方式，这里“随机”是指可以跳转到文件的任意位置处读写数据。 在访问一个文件的时候，不必把文件从头读到尾，而是希望像访问一个数据库一样“随心所欲”地访问一个文件的某个部分，这时使用类就是最佳选择。\u200e RandomAccessFile对象类有个位置指示器\u200e\u200e，指向当前读写处的位置，当前读写n个字节后，文件指示器将指向这n个字节后面的下一个字节处。 刚打开文件时，文件指示器指向文件的开头处，可以移动文件指示器到新的位置，随后的读写操作将从新的位置开始。 类在数据等长记录格式文件的随机（相对顺序而言）读取时有很大的优势，但该类仅限于操作文件，不能访问其他的I/O设备，如网络、内存映像等。\nIO Stream 分类 根据操作数据类型（能用记事本打开并能看到其中的字符内容的是文本文件，反之是二进制文件）\n字节流：二进制，以字节为单位\n字节流的两个基类 InputStream和OutputStream\n凡是以InputStream或OutputStream结尾的类型为字节流\n字符流：文本,以字符（2个字节）为单位\n字符流的两个基类 Reader和Writer\n凡是以Reader或Writer结尾的均为字符流\n区别\n字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用colse()方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法； 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节； 处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据； 根据流向\n输入流 输出流 根据具体功能\n节点流：以从或向一个特定的地方（节点）读写数据。\n1、文件： FileInputStream 、FileOutputStream、 FileReader和 FileWriter 文件进行处理的节点流； 2、字符串： StringReader 和StringWriter 对字符串进行处理的节点流； 3、数组： ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader和CharArrayWriter 对数组进行处理的节点流(对应的不再是文件，而是内存中的一个数组)； 4、管道： PipedInputStream 、PipedOutputStream 和PipedReaderPipedWriter对管道进行处理的节点流； 5、基类： InputStream、 OutputStream、 Reader和 Writer；\n处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。\n1、缓冲流：BufferedInputStream、 BufferedOutputStream、 BufferedReader和BufferedWriter 增加缓冲功能，避免频繁读写硬盘。 "><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu17834253352308399148.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#file类>File类</a></li><li><a href=#io-stream><strong>IO Stream</strong></a><ol><li><ol><li><a href=#分类>分类</a></li><li><a href=#关闭流>关闭流</a></li><li><a href=#inputstream>InputStream</a></li><li><a href=#outputstream>OutputStream</a></li><li><a href=#reader>Reader</a></li><li><a href=#writer>Writer</a></li><li><a href=#systemin-and-systemout><code>System.in</code> and <code>System.out</code></a></li><li><a href=#对象流>对象流</a></li><li><a href=#总结>总结</a></li></ol></li></ol></li><li><a href=#nio>NIO</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/nutrition/ style=background-color:#93b5cf;color:>积雪粮
</a><a href=/categories/temple/ style=background-color:#69a794;color:>白玉京</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/javaio/>【Java】IO</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jan 05, 2022</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>1 minute read</time></div></footer></div></header><section class=article-content><p>从文件中读取内容，向文件中写入内容，截短文件、合并文 件、压缩文件……，诸如此类的操作，称为<strong>文件存取操作</strong>， 主要使用“流（Stream）”来完成</p><p>与文件操作相关的类，集中于java.io包中。</p><p>Java 1.4中加入了一个New I/O API，提供了一些类完成文件和流操作。</p><p>Java 7中又加入了一些新类型，称为NIO.2，NIO.2中最重要的是引入了<strong>Path</strong>和 <strong>AutoCloseable</strong>接口，还有一个<strong>Files类</strong>，它的静态方法封装了文件的常用操作。</p><h2 id=file类>File类</h2><p>Java使用File类来统一操作文件和文件夹。</p><ul><li>java.io.File代表与平台无关的文件或目录。也就是说可以通过File类在Java程序中操作文件或目录；</li></ul><ul><li>File类只能用来<strong>操作</strong>文件或目录（包括新建、删除、重命名文件和目录等操作），但<strong>不能用来访问</strong>文件中的内容；</li><li>如果需要访问文件中的内容，则需要使用输入/输出流。</li></ul><p><code>RandomAccessFile</code>（随机文件操作）：一个独立的类，直接继承至Object.它的功能丰富，可以从文件的任意位置进行存取（输入输出）操作。<code>RandomAccessFile</code>类支持“随机访问”方式，这里“随机”是指可以跳转到文件的任意位置处读写数据。 在访问一个文件的时候，不必把文件从头读到尾，而是希望像访问一个数据库一样“随心所欲”地访问一个文件的某个部分，这时使用类就是最佳选择。‎
<code>RandomAccessFile</code>对象类有个<strong>位置指示器‎</strong>‎，指向当前读写处的位置，当前读写n个字节后，文件指示器将指向这n个字节后面的下一个字节处。 刚打开文件时，文件指示器指向文件的开头处，可以移动文件指示器到新的位置，随后的读写操作将从新的位置开始。 类在数据等长记录格式文件的随机（相对顺序而言）读取时有很大的优势，但该类仅限于操作文件，不能访问其他的I/O设备，如网络、内存映像等。</p><h2 id=io-stream><strong>IO Stream</strong></h2><h4 id=分类>分类</h4><ul><li><p>根据操作数据类型（<em>能用记事本打开并能看到其中的字符内容的是文本文件，反之是二进制文件</em>）</p><ul><li><p>字节流：二进制，以字节为单位</p><p>字节流的两个基类 InputStream和OutputStream</p><p>凡是以InputStream或OutputStream结尾的类型为字节流</p></li><li><p>字符流：文本,以字符（2个字节）为单位</p><p>字符流的两个基类 Reader和Writer</p><p>凡是以Reader或Writer结尾的均为字符流</p></li><li><p>区别</p><ul><li>字节流没有缓冲区，是直接输出的，而字符流是输出到缓冲区的。因此在输出时，字节流不调用<code>colse()</code>方法时，信息已经输出了，而字符流只有在调用close()方法关闭缓冲区时，信息才输出。要想字符流在未关闭时输出信息，则需要手动调用flush()方法；</li><li>读写单位不同：字节流以字节（<code>8bit</code>）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节；</li><li>处理对象不同：字节流能处理所有类型的数据（如图片、<code>avi</code>等），而字符流只能处理字符类型的数据；</li></ul></li></ul></li><li><p>根据流向</p><ul><li>输入流</li><li>输出流</li></ul></li><li><p>根据具体功能</p><ul><li><p>节点流：以从或向一个特定的地方（节点）读写数据。</p><p>1、文件： <code>FileInputStream</code> 、<code>FileOutputStream</code>、 <code>FileReader</code>和 <code>FileWriter</code> 文件进行处理的节点流； 　　</p><p>2、字符串： <code>StringReader</code> 和<code>StringWriter</code> 对字符串进行处理的节点流； 　　</p><p>3、数组： <code>ByteArrayInputStream</code>、<code>ByteArrayOutputStream</code>、<code>CharArrayReader</code>和<code>CharArrayWriter</code> 对数组进行处理的节点流(对应的不再是文件，而是内存中的一个数组)； 　　</p><p>4、管道： <code>PipedInputStream</code> 、<code>PipedOutputStream</code> 和<code>PipedReaderPipedWriter</code>对管道进行处理的节点流； 　　</p><p>5、基类： <code>InputStream</code>、 <code>OutputStream</code>、 <code>Reader</code>和 <code>Writer</code>；</p></li><li><p>处理流：是对一个已存在的流的<strong>连接和封装</strong>，通过所封装的流的功能调用实现数据读写。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</p><p>1、缓冲流：<code>BufferedInputStream</code>、 <code>BufferedOutputStream</code>、 <code>BufferedReader</code>和<code>BufferedWriter</code> 　增加缓冲功能，避免频繁读写硬盘。 　　</p><p>2、转换流：<code>InputStreamReader</code>和 <code>OutputStreamReader</code>实现字节流和字符流之间的转换。 　　</p><p>3、数据流 <code>DataInputStream</code>和<code>DataOutputStream</code>等提供将基础数据类型写入到文件中，或者读取出来。</p></li></ul></li></ul><p><img src="https://pics2.baidu.com/feed/6159252dd42a28341e23dde5587a81ec17cebfa8.jpeg?token=201587ab58af94624ef1a60c83d1e396&amp;s=C8611F7091BFE5CC1C5D95CB000030B2" loading=lazy alt=img></p><p><img src=https://pic4.zhimg.com/80/v2-a001c51e37e77edf5a73dbba3bc80153_1440w.jpg loading=lazy alt=img></p><h4 id=关闭流>关闭流</h4><p><strong>流关闭的原则</strong>：先打开先关闭；如果A依赖B，则先关闭A再关闭B；对于处理流如果将节点流关闭以后再关闭处理流，会抛出IO异常，所以直接关闭处理流就行了，会自动调用关闭里面节点流的方法。</p><blockquote><p><strong>注意</strong>：</p><ul><li>如果将节点流关闭以后再关闭处理流，会抛出IO异常</li><li>如果关闭了处理流，在关闭与之相关的节点流，也可能出现IO异常。</li></ul></blockquote><h4 id=inputstream>InputStream</h4><p><img src=https://pic1.zhimg.com/80/v2-d464303fd5be6fdb7b11678857824520_1440w.jpg loading=lazy alt=img></p><p><code>ByteArrayInputStream</code>：字节数组输入流，它的内部缓冲区就是一个字节数组，该类的功能就是从字节数组(<code>byte[]</code>)中进行以字节为单位的读取资源文件；</p><p><code>PipedInputStream</code>：管道字节输入流，它和<code>PipedOutputStream</code>一起使用，能实现**多线程间的管道通信。**多线程管道通信的主要流程是在一个线程中向<code>PipedOutputStream</code>写入数据，这些数据会自动传送到对应的管道输入流<code>PipedInputStream</code>中，其他线程通过读取<code>PipeInputStream</code>中缓冲的数据实现多线程间通信；</p><p><code>FilterInputStream</code> ：过滤输入流，装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。常见的子类有<code>DataInputStream</code>和<code>BufferedInputStream</code>；</p><p><code>BufferedInputStream</code>：缓冲输入流，由于基础输入流一个字节一个字节读取,频繁与磁盘进行交互,造成读取速度较低.缓冲流的存在就是先将数据读取到缓冲流(内存中),然后一次性从内存中读取多个字符.提高读取的效率；</p><p><code>DataInputStream</code>：数据输入流,以机器无关的方式读取Java的基本类型；</p><p><code>FileInputSream</code>：文件输入流，它通常用于对文件进行读取操作；</p><p><code>File</code>：对指定目录的文件进行操作。注意，该类虽然是在IO包下，但是并不继承自四大基础类；</p><p><code>ObjectInputStream</code>：对象输入流，用来提供对“基本数据或对象”的持久存储。通俗点讲，也就是能直接传输对象（反序列化中使用）。</p><h4 id=outputstream>OutputStream</h4><p><img src=https://pic4.zhimg.com/80/v2-e208c6f6b8021e0d2a3c519fcbecb6d7_1440w.jpg loading=lazy alt=img></p><p><code>ByteArrayOutputStream</code>：字节数组输出流，它的内部缓冲区就是一个字节数组，该类的功能就是从字节数组(<code>byte[]</code>)中进行以字节为单位的写入资源文件；</p><p><code>PipedOutputStream</code> ：管道字节输出流，它和<code>PipedInputStream</code>一起使用，能实现<strong>多线程间的管道通信。</strong></p><p><code>FilterOutputStream</code> ：过滤输出流，装饰者模式中处于装饰者，具体的装饰者都要继承它，所以在该类的子类下都是用来装饰别的流的，也就是处理类。常见的子类有<code>DatOutputStream</code>、<code>BufferedOutputStream</code>和</p><p><code>BufferedOutputStream</code>：缓冲输出流，由于基础输入流一个字节一个字节写入,频繁与磁盘进行交互,造成读取速度较低.缓冲流的存在就是先将数据写入到缓冲流(内存中),然后一次性从内存中写入多个字符.提高读取的效率；</p><p><code>DataOutputStream</code>：数据输出流,以机器无关的方式读取Java的基本类型；</p><p><code>PrintStream</code>：继承了<code>FilterOutputStream</code>。是"装饰类"的一种,所以属于字节流体系中(与<code>PrintStream</code>相似的流<code>PrintWriter</code>继承于<code>Writer</code>,属于字符流体系中),为其他的输出流添加功能.使它们能够方便打印各种数据值的表示形式；</p><p><code>FileOutputStream</code> ：文件输出流，它通常用于对文件进行写入操作；</p><p><code>ObjectOutputStream</code> ：对象输出流，用来提供对“基本数据或对象”的持久存储。通俗点讲，也就是能直接传输对象（反序列化中使用），和所有<code>FilterOutputStream</code> 的子类都是装饰流(序列化中使用)。</p><h4 id=reader>Reader</h4><p><img src=https://pic1.zhimg.com/80/v2-0e823bac3cb2feab11a1d7db5b598dc4_1440w.jpg loading=lazy alt=img></p><p><code>CharArrayReader</code> :字符数组输入流。它和<code>ByteArrayInputStream</code>类似，只不过<code>ByteArrayInputStream</code>是字节数组输入流，而<code>CharArray</code>是字符数组输入流</p><p><code>PipedReader</code>:管道字符流， 是从与其它线程共用的管道中读取数据。</p><p><code>FilterReader</code>：过滤输入字符流， 是所有自定义具体装饰流的父类，为所有装饰类提供一个标准、只是简单重写了父类Reader的所有方法、要求子类必须重写核心方法、和提供具有自己特色的方法、这里没有像字节流那样有很多的子类来实现不同的功能、可能是因为字符流本来就是字节流的一种装饰、所以在这里没有必要再对其进行装饰、只是提供一个扩展的接口而已；</p><p><code>BufferedReader</code>：缓冲字符流， 为了提高字符流读写的效率，引入了缓冲机制，进行字符批量的读写，提高了单个字符读写的效率；</p><p><code>InputStreamReader</code>是一个连接字节流和字符流的桥梁，它将字节流转变为字符流；</p><p><code>FileReader</code>：继承<code>InputStreamReader</code>，可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将<code>FileInputStream</code> 转变为<code>Reader</code> 的方法。我们可以从这个类中得到一定的技巧。<code>Reader</code> 中各个类的用途和使用方法基本和<code>InputStream</code> 中的类使用一致。后面会有<code>Reader</code> 与<code>InputStream</code> 的对应关系。</p><h4 id=writer>Writer</h4><p><img src=https://pic1.zhimg.com/80/v2-e0bddfb105d00fe202435737684e8240_1440w.jpg loading=lazy alt=img></p><p><code>CharArrayWriter</code>、<code>StringWriter</code> 是两种基本的介质流，它们分别向<code>Char</code> 数组、<code>String</code> 中写入数据。</p><p><code>PipedWriter</code> 是向与其它线程共用的管道中写入数据 <code>BufferedWriter</code> 是一个装饰器为<code>Writer</code> 提供缓冲功能。</p><p><code>PrintWriter</code> 和<code>PrintStream</code> 极其类似，功能和使用也非常相似。</p><p><code>OutputStreamWriter</code> 是<code>OutputStream</code> 到<code>Writer</code> 转换的桥梁，它的子类<code>FileWriter</code> 其实就是一个实现此功能的具体类。功能和使用和<code>OutputStream</code> 极其类似。</p><p>转换流</p><p><strong>4.1、定义</strong>：字符和字节直接的转换，是字符流和字节流之间的桥梁，文本文件在硬盘中以字节流的形式存储时，通过<code>InputStreamReader</code>读取后转化为字符流给程序处理，即可对读取到的字节数据经过指定编码转换成字符；程序处理的字符流通过<code>OutputStreamWriter</code>转换为字节流保存，即可对读取到的字符数据经过指定编码转换成字节。</p><p><strong>4.2、何时使用转换流？</strong></p><p>①当字节和字符之间有转换动作时； ②流操作的数据需要编码或解码时。</p><p><strong>4.3、具体的对象体现：</strong></p><p><code>InputStreamReader</code>:字节到字符的桥梁 <code>OutputStreamWriter</code>:字符到字节的桥梁 这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来，即：</p><p><code>InputStreamReader(InputStream in</code>)：将字节流以字符流输入。</p><p><code>OutputStreamWriter</code>(<code>OutStreamout</code>):将字节流以字符流输出。</p><h4 id=systemin-and-systemout><code>System.in</code> and <code>System.out</code></h4><p><strong>System.in</strong>和<strong>System.out</strong>分别代表了系统标准的输入和输出设备
默认输入设备是：键盘，输出设备是：显示器
System.in的类型是InputStream
System.out的类型是PrintStream</p><h4 id=对象流>对象流</h4><p>ObjectInputStream和OjbectOutputSteam用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</p><ul><li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</li><li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</li></ul><p>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</p><h4 id=总结>总结</h4><p><code>InputStream</code>类的功能不足被<code>Scanner</code>解决了</p><p><code>OutputStream</code>类的功能不足被<code>PrintStream</code>解决了</p><p><code>Reader</code>类功能不足被<code>BufferReader</code>解决了</p><p><code>Writer</code>类的功能不足被<code>PrintWriter</code>解决了</p><p>输出数据用<code>printStream</code>，<code>printwriter</code>读取数据用<code>Scanner</code>其次是<code>bufferReader</code></p><h2 id=nio>NIO</h2><p>java.nio全称java non-blocking IO，是指jdk1.4 及以上版本里提供的新api（New IO） ，为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。</p></section><footer class=article-footer><section class=article-tags><a href=/tags/java/>Java</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Jan 05, 2022 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/javaenum/><div class=article-image><img src=/covers/cover19.png loading=lazy data-key data-hash=/covers/cover19.png></div><div class=article-details><h2 class=article-title>【Java】Enum</h2></div></a></article><article class=has-image><a href=/p/javadates-and-times/><div class=article-image><img src=/covers/cover19.png loading=lazy data-key data-hash=/covers/cover19.png></div><div class=article-details><h2 class=article-title>【Java】Dates and Times</h2></div></a></article><article class=has-image><a href=/p/javareleases/><div class=article-image><img src=/covers/cover9.png loading=lazy data-key data-hash=/covers/cover9.png></div><div class=article-details><h2 class=article-title>【Java】Releases</h2></div></a></article><article><a href=/p/java%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84/><div class=article-details><h2 class=article-title>【Java】注解与反射</h2></div></a></article><article><a href=/p/java%E9%87%91%E6%97%AD%E4%BA%AE-java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/><div class=article-details><h2 class=article-title>【Java】金旭亮-Java程序设计</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>