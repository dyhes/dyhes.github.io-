<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="图形系统 光栅图像 也称为图像、位图、点阵图、像素图，以像素数组的形式存贮在帧缓冲区中\n基本图元 点 设置点大小 glPointSize(Glfloat size); 设置点绘制模式 glBegin(GL_POINTS); glEnd(); 设置点位置 glVertex3f(Glfloat x, Glfloat y, Glfloat z); 设置点颜色 glColor3f(Glfloat r, Glfloat g, Glfloat b); 光滑（反走样） glEnable (GL_POINT_SMOOTH); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA); 直线 设置线的宽度 glLineWidth(Glfloat width)\n设置直线绘制模式 glBegin(GL_LINES); 两两连线 glBegin(GL_LINE_STRIP)；持续连线 glBegin(GL_LINE_LOOP)；首尾也相连\n点画线(虚线) glEnable(GL_LINE_STIPPLE); glLineStipple(GLint factor, GLushort pattern);\n光滑（反走样）\nglEnable (GL_LINE_SMOOTH); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);\n三角形 设置三角型绘制模式\nglBegin(GL_TRIANGLES);\nGL_TRIANGLE_STRIP； 三角带\nGL_TRIANGLE_FAN； 三角扇\n着色模式 glShadeModel(GL_FLAT); glShadeModel(GL_SMOOTH);\n背面消除 glEnable(GL_CULL_FACE); glFrontFace(GL_CCW) GL_CW\n"><title>【计算机图形学】笔记</title>
<link rel=canonical href=https://dyhes.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/><link rel=stylesheet href=/scss/style.min.6aa4d43a5cae1c51ef34b3f851ae7421f4b2f2d13827e2d975acbeb4f13c8710.css><meta property='og:title' content="【计算机图形学】笔记"><meta property='og:description' content="图形系统 光栅图像 也称为图像、位图、点阵图、像素图，以像素数组的形式存贮在帧缓冲区中\n基本图元 点 设置点大小 glPointSize(Glfloat size); 设置点绘制模式 glBegin(GL_POINTS); glEnd(); 设置点位置 glVertex3f(Glfloat x, Glfloat y, Glfloat z); 设置点颜色 glColor3f(Glfloat r, Glfloat g, Glfloat b); 光滑（反走样） glEnable (GL_POINT_SMOOTH); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA); 直线 设置线的宽度 glLineWidth(Glfloat width)\n设置直线绘制模式 glBegin(GL_LINES); 两两连线 glBegin(GL_LINE_STRIP)；持续连线 glBegin(GL_LINE_LOOP)；首尾也相连\n点画线(虚线) glEnable(GL_LINE_STIPPLE); glLineStipple(GLint factor, GLushort pattern);\n光滑（反走样）\nglEnable (GL_LINE_SMOOTH); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);\n三角形 设置三角型绘制模式\nglBegin(GL_TRIANGLES);\nGL_TRIANGLE_STRIP； 三角带\nGL_TRIANGLE_FAN； 三角扇\n着色模式 glShadeModel(GL_FLAT); glShadeModel(GL_SMOOTH);\n背面消除 glEnable(GL_CULL_FACE); glFrontFace(GL_CCW) GL_CW\n"><meta property='og:url' content='https://dyhes.github.io/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/'><meta property='og:site_name' content='飞鸿踏雪泥'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2023-06-06T00:00:00+00:00'><meta property='article:modified_time' content='2023-06-06T00:00:00+00:00'><meta name=twitter:title content="【计算机图形学】笔记"><meta name=twitter:description content="图形系统 光栅图像 也称为图像、位图、点阵图、像素图，以像素数组的形式存贮在帧缓冲区中\n基本图元 点 设置点大小 glPointSize(Glfloat size); 设置点绘制模式 glBegin(GL_POINTS); glEnd(); 设置点位置 glVertex3f(Glfloat x, Glfloat y, Glfloat z); 设置点颜色 glColor3f(Glfloat r, Glfloat g, Glfloat b); 光滑（反走样） glEnable (GL_POINT_SMOOTH); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA); 直线 设置线的宽度 glLineWidth(Glfloat width)\n设置直线绘制模式 glBegin(GL_LINES); 两两连线 glBegin(GL_LINE_STRIP)；持续连线 glBegin(GL_LINE_LOOP)；首尾也相连\n点画线(虚线) glEnable(GL_LINE_STIPPLE); glLineStipple(GLint factor, GLushort pattern);\n光滑（反走样）\nglEnable (GL_LINE_SMOOTH); glEnable (GL_BLEND); glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);\n三角形 设置三角型绘制模式\nglBegin(GL_TRIANGLES);\nGL_TRIANGLE_STRIP； 三角带\nGL_TRIANGLE_FAN； 三角扇\n着色模式 glShadeModel(GL_FLAT); glShadeModel(GL_SMOOTH);\n背面消除 glEnable(GL_CULL_FACE); glFrontFace(GL_CCW) GL_CW\n"><link rel="shortcut icon" href=/github.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu17834253352308399148.png width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>飞鸿踏雪泥</a></h1><h2 class=site-description>没有记录，就没有发生</h2></div></header><ol class=menu-social><li><a href=https://github.com/dyhes target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:dyheslin@gmail.com target=_blank title=Gmail rel=me><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-gmail"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M16 20h3a1 1 0 001-1V5a1 1 0 00-1-1h-3v16z"/><path d="M5 20h3V4H5A1 1 0 004 5v14a1 1 0 001 1z"/><path d="M16 4l-4 4-4-4"/><path d="M4 6.5l8 7.5 8-7.5"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#图形系统>图形系统</a></li><li><a href=#光栅图像>光栅图像</a></li><li><a href=#基本图元>基本图元</a><ol><li><a href=#点>点</a></li><li><a href=#直线>直线</a></li><li><a href=#三角形>三角形</a></li></ol></li><li><a href=#坐标系>坐标系</a></li><li><a href=#深度缓冲>深度缓冲</a></li><li><a href=#四种变换>四种变换</a><ol><li><a href=#控制模型>控制模型</a></li><li><a href=#控制视点>控制视点</a></li></ol></li><li><a href=#控制>控制</a></li><li><a href=#矩阵>矩阵</a><ol><li><a href=#空间变换>空间变换</a></li></ol></li><li><a href=#旋转>旋转</a></li><li><a href=#方位>方位</a></li><li><a href=#欧拉角>欧拉角</a></li><li><a href=#四元数>四元数</a><ol><li><a href=#四元数插值>四元数插值</a><ol><li><a href=#slerp插值>Slerp插值</a></li><li><a href=#squad插值>Squad插值</a></li></ol></li></ol></li><li><a href=#视点控制>视点控制</a></li><li><a href=#包围盒>包围盒</a></li><li><a href=#光照>光照</a></li><li><a href=#纹理>纹理</a></li><li><a href=#特殊效果>特殊效果</a></li><li><a href=#opengl内部矩阵>OpenGL内部矩阵</a><ol><li><a href=#gl_modelview模型视图矩阵>GL_MODELVIEW（模型视图矩阵）</a></li><li><a href=#gl_projection投影矩阵>GL_PROJECTION（投影矩阵）</a></li><li><a href=#gl_texture纹理矩阵>GL_TEXTURE（纹理矩阵）</a></li></ol></li><li><a href=#opengl函数>OpenGL函数</a><ol><li><a href=#glreadpixels>glReadPixels</a></li><li><a href=#glutinitdisplaymodeunsigned-int-mode>glutInitDisplayMode(unsigned int mode);</a></li><li><a href=#glclearcolorrbga>glClearColor(r,b,g,a);</a></li><li><a href=#glclearglbitfield-mask>glClear(GLbitfield mask);</a></li><li><a href=#glflushglfinish>glFlush()/glFinish()</a></li><li><a href=#glswapbuffer>glSwapBuffer()</a></li><li><a href=#glbegin>glBegin();</a></li><li><a href=#glend>glEnd();</a></li><li><a href=#glenable>glEnable():</a></li><li><a href=#gldisable>glDisable()</a></li><li><a href=#glshademodel>glShadeModel()</a></li><li><a href=#glfrontfaceglenum-mode><strong>glFrontFace</strong>(GLenum <em>mode</em>)</a></li><li><a href=#glpolygonmodeglenum-faceglenum-mode>glPolygonMode(GLenum face,GLenum mode)</a></li><li><a href=#gltranslatefxyz>glTranslatef(x,y,z)</a></li><li><a href=#glscalefxyz>glScalef(x,y,z)</a></li><li><a href=#glrotatefangleabc>glRotatef(angle,a,b,c)</a></li><li><a href=#glloadidentity><strong>glLoadIdentity()</strong></a></li><li><a href=#glclipplaneglenum-planeconst-gldouble-equation>glClipPlane(GLenum plane,Const GLdouble *equation);</a></li><li><a href=#gluunproject>gluUnProject()</a></li><li><a href=#glulookat>gluLookAt()</a></li><li><a href=#gluperspectivegldouble-fovy-gldouble-aspect-gldouble-znear-gldouble-zfar->gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar );</a></li><li><a href=#void-glortho-gldouble-left-gldouble-right-gldouble-bottom-gldouble-top-gldouble-znear-gldouble-zfar->void glOrtho( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );</a></li><li><a href=#glpushmatrix>glPushMatrix()</a></li><li><a href=#glpopmatrix>glPopMatrix()</a></li><li><a href=#glmatrixmode>glMatrixMode()</a></li><li><a href=#glloadmatrixfm>glLoadMatrixf(M)</a></li><li><a href=#glmultmatrixfm>glMultMatrixf(M)</a></li><li><a href=#glkeybordfuncunsigned-char-keyint-xint-y>glKeybordFunc(unsigned char key,int x,int y)</a></li><li><a href=#gluttimerfuncunsigned-int-millis-void-funcint-value-int-value>glutTimerFunc(unsigned int millis, void (*func)(int value), int value)</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/star/ style=background-color:#2e317c;color:>一天星</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%AC%94%E8%AE%B0/>【计算机图形学】笔记</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 06, 2023</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>4 minute read</time></div></footer></div></header><section class=article-content><h2 id=图形系统>图形系统</h2><p><img src=https://i.ibb.co/pbyr85r/image-20220518170931699.png loading=lazy alt=image-20220518170931699></p><h2 id=光栅图像>光栅图像</h2><p>也称为图像、位图、点阵图、像素图，以像素数组的形式存贮在帧缓冲区中</p><h2 id=基本图元>基本图元</h2><h3 id=点>点</h3><ul><li>设置点大小
glPointSize(Glfloat size);</li><li>设置点绘制模式
glBegin(GL_POINTS);
glEnd();</li><li>设置点位置
glVertex3f(Glfloat x, Glfloat y, Glfloat z);</li><li>设置点颜色
glColor3f(Glfloat r, Glfloat g, Glfloat b);</li><li>光滑（反走样）
glEnable (GL_POINT_SMOOTH);
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);</li></ul><h3 id=直线>直线</h3><ul><li><p>设置线的宽度
glLineWidth(Glfloat width)</p></li><li><p>设置直线绘制模式
glBegin(GL_LINES); 两两连线
glBegin(GL_LINE_STRIP)；持续连线
glBegin(GL_LINE_LOOP)；首尾也相连</p></li><li><p>点画线(虚线)
glEnable(GL_LINE_STIPPLE);
glLineStipple(GLint factor, GLushort pattern);</p></li><li><p>光滑（反走样）</p><p>glEnable (GL_LINE_SMOOTH);
glEnable (GL_BLEND);
glBlendFunc (GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);</p></li></ul><h3 id=三角形>三角形</h3><ul><li><p>设置三角型绘制模式</p><p>glBegin(GL_TRIANGLES);</p><p>GL_TRIANGLE_STRIP； 三角带</p><p>GL_TRIANGLE_FAN； 三角扇</p></li><li><p>着色模式
glShadeModel(GL_FLAT);
glShadeModel(GL_SMOOTH);</p></li><li><p>背面消除
glEnable(GL_CULL_FACE);
glFrontFace(GL_CCW) GL_CW</p></li><li><p>多边形模式
glPolygonMode(GL_BACK,GL_LINE);
GL_BACK/GL_FRONT/GL_FRONT_AND_BACK
GL_LINE/GL_POINT/GL_FILL</p></li></ul><h2 id=坐标系>坐标系</h2><p>使用OpenGL方式定义坐标系：<strong>右手</strong>坐标系</p><ul><li><p>世界坐标系</p><p><strong>最大</strong>的坐标系，描述其他坐标系的参考框架</p></li><li><p>物体（模型）坐标系</p><p>与特定<strong>物体相关</strong></p><p>随着物体运动而运动</p></li><li><p>惯性坐标系</p><p>物体坐标系到世界坐标系转换的<strong>中间阶段</strong></p><p>位置与物体坐标系一致，方向与世界坐标系一致</p></li></ul><p>物体坐标系转世界坐标系：以惯性坐标系为媒介，旋转至惯性坐标系后平移至世界坐标系</p><h2 id=深度缓冲>深度缓冲</h2><ul><li>显示模式设置为深度缓冲区
glutInitDisplayMode(GLUT_DEPTH);</li><li>设置深度缓冲区允许位
glEnable(GL_DEPTH_TEST);</li><li>每帧绘制前清除深度缓冲区
glClear(GL_DEPTH_BUFFER_BIT);</li></ul><h2 id=四种变换>四种变换</h2><p><img src="https://img-blog.csdnimg.cn/20210122164933255.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tpbmdzTWFuNjY2,size_16,color_FFFFFF,t_70#pic_center" loading=lazy alt=三维图形显示和相机拍照之间的对应关系></p><p>模型变换和视点变换本质上是一致的,对一个的变换相当于对另一个反方向变换</p><p>模型视点变换：通过模型变换从局部坐标系转换为世界坐标系，再通过视点变换从世界坐标系转换为视口坐标系</p><h3 id=控制模型>控制模型</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>glTranslatef</span><span class=p>(</span><span class=n>mx</span><span class=p>,</span><span class=n>my</span><span class=p>,</span><span class=n>mz</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glRotatef</span><span class=p>(</span><span class=n>rx</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glRotatef</span><span class=p>(</span><span class=n>ry</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glRotatef</span><span class=p>(</span><span class=n>rz</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glScalef</span><span class=p>(</span><span class=n>sx</span><span class=p>,</span><span class=n>sy</span><span class=p>,</span><span class=n>sz</span><span class=p>);</span>
</span></span></code></pre></div><h3 id=控制视点>控制视点</h3><ul><li><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>glRotatef</span><span class=p>(</span><span class=o>-</span><span class=n>rz</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glRotatef</span><span class=p>(</span><span class=o>-</span><span class=n>ry</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glRotatef</span><span class=p>(</span><span class=o>-</span><span class=n>rx</span><span class=p>,</span><span class=mi>1</span><span class=p>,</span><span class=mi>0</span><span class=p>,</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>glTranslatef</span><span class=p>(</span><span class=o>-</span><span class=n>mx</span><span class=p>,</span><span class=o>-</span><span class=n>my</span><span class=p>,</span><span class=o>-</span><span class=n>mz</span><span class=p>);</span>
</span></span></code></pre></div></li></ul><h2 id=控制>控制</h2><ul><li><p>控制键盘</p><p>glutKeyboardFunc(&amp;myKeyboardFunc);</p></li></ul><h2 id=矩阵>矩阵</h2><p>列向量只可以右乘矩阵（结果仍为列向量），用在OpenGL、多数图形学书籍中。</p><p>向量可由三个线性无关的基向量的线性组合表示</p><p>由基向量构成的矩阵就是坐标系</p><h3 id=空间变换>空间变换</h3><p>两种变换等价，将物体变换一个量相当于将原始坐标系变换一个相反的量</p><p>在实际的3D对象绘制过程中，实质上是进行的坐标系的变换，以节省大量的计算时间。</p><ul><li><p>变换物体：物体上所有点变换到新位置，坐标改变</p><p><img src=https://i.ibb.co/wKpd0cG/image-20220519115346305.png loading=lazy alt=image-20220519115346305></p></li><li><p>变换坐标系：物体上的点没有移动，在新的坐标系中描述（计算量小，速度快）</p><p><img src=https://i.ibb.co/Gk2Nhw4/image-20220519115531727.png loading=lazy alt=image-20220519115531727></p></li></ul><p>坐标系变换理解</p><ul><li>正向：<img src=https://i.ibb.co/BBKL4kd/image-20220519121924407.png loading=lazy alt=image-20220519121924407></li><li>逆向：<img src=https://i.ibb.co/jkCdGkY/image-20220519121837565.png loading=lazy alt=image-20220519121837565></li></ul><p>在坐标系M下的a向量表示为 <strong>Ma</strong>
其在坐标系N下表示为 <strong>b</strong>= <strong>N-1Ma</strong>（<strong>Ma=Nb</strong>）</p><h2 id=旋转>旋转</h2><p>旋转的正方向:由右手定则判定，拇指向上，四指弯曲。拇指方向是坐标轴正方向，四指弯曲方向则为旋转正方向</p><h2 id=方位>方位</h2><p>通过与相对已知方位（源方位）的旋转来表述，旋转的量称作角位移</p><p>初始方位：自旋转角度为0，方向为（0,0,-1）（z轴负向），此时欧拉角为（0，0，0）</p><h2 id=欧拉角>欧拉角</h2><p><strong>角位移</strong>分解为绕三个<strong>相互垂直的轴</strong>的三个旋转组成的序列</p><ul><li>heading/yaw 偏航 h (y轴)</li><li>pitch 俯仰/ 纵摇 p(x轴)</li><li>bank/roll 倾侧/翻滚 b(z轴)</li></ul><p>初始方位角为（0，0，-1），转动为0</p><p>取值范围限定 h,b在-180到180，p在-90到90</p><h2 id=四元数>四元数</h2><p>包括一个标量和一个3D向量，代表一角位移：绕n转θ角，q与-q代表相同的角位移</p><ul><li><p>单位四元数</p><p><img src=https://i.ibb.co/Y00LWP9/image-20220622150418003.png loading=lazy alt=image-20220622150418003></p></li><li><p>共轭四元数：向量部分变负</p><p>q*=[w v]*=[w -v]</p></li><li><p>四元数的逆：共轭除以模的平方</p><p><img src=https://i.ibb.co/VS04Bfr/image-20220622150114195.png loading=lazy alt=image-20220622150114195></p><p>qq-1=[1,0]</p></li><li><p>四元数乘法</p><p><img src=https://i.ibb.co/CJN1pnf/image-20220622145812616.png loading=lazy alt=image-20220622145812616></p><ul><li><p>满足结合律，不满足交换律</p></li><li><p>四元数乘的模等于模的乘积，单位四元数的乘仍然是单位四元数</p><p><img src=https://i.ibb.co/r0mKbYc/image-20220622150055802.png loading=lazy alt=image-20220622150055802></p></li><li><p>四元数乘积的逆等于各四元数逆反顺序相乘</p><p><img src=https://i.ibb.co/Rhtfyz3/image-20220622150040033.png loading=lazy alt=image-20220622150040033></p><p>扩展3d点(x,y,z)到四元数空间为p=[0,(x,y,z)]</p><p>设q为单位化四元数，n为旋转轴,θ为旋转角。则p绕n旋转θ公式为：</p><p><img src=https://i.ibb.co/BGNxFJf/image-20220622150643141.png loading=lazy alt=image-20220622150643141></p><p>若q为一般形式的四元数，可通过标准化转换求得旋转轴和旋转角度</p><p>连续旋转：先转a,再转b，等于执行ba旋转</p><p><img src=https://i.ibb.co/4Jt5XWk/image-20220622152104195.png loading=lazy alt=image-20220622152104195></p></li></ul></li><li><p>新乘法</p><p><img src=https://i.ibb.co/2hbFNg5/image-20220622152016441.png loading=lazy alt=image-20220622152016441></p><p>在新四元数乘法定义下：先a旋转，再b旋转，等于执行一次ab旋转。乘法顺序与旋转顺序相同。</p><p><img src=https://i.ibb.co/x5wPBj8/image-20220622152043474.png loading=lazy alt=image-20220622152043474></p><p><img src=https://i.ibb.co/sQGm8vZ/image-20220622152213642.png loading=lazy alt=image-20220622152213642></p></li><li><p>四元数的差：一个方位到另一个方位的角位移</p><p><img src=https://i.ibb.co/HxSZM6w/image-20220622152602016.png loading=lazy alt=image-20220622152602016></p></li><li><p>四元数点乘：对于单位四元数a,b有-1&lt;=a*b&lt;=1，其点乘越大，则a、b所代表的角位移越相似</p><p><img src=https://i.ibb.co/X8wCyHG/image-20220622152707212.png loading=lazy alt=image-20220622152707212></p><p>θ为a、b之差d的夹角，则</p><p><img src=https://i.ibb.co/JxKXnjS/image-20220622152922378.png loading=lazy alt=image-20220622152922378></p></li><li><p>四元数对数</p><p>记α为θ/2,定义：</p><p><img src=https://i.ibb.co/1v68G7z/image-20220622153042707.png loading=lazy alt=image-20220622153042707></p></li><li><p>四元数指数</p><p><img src=https://i.ibb.co/Ypc7VG8/image-20220622153158545.png loading=lazy alt=image-20220622153158545></p></li><li><p>四元数数乘：标量值直接乘以四元数中每个分量，满足交换律</p><p><img src=https://i.ibb.co/pZGT2dg/image-20220622153247625.png loading=lazy alt=image-20220622153247625></p></li><li><p>四元数的幂：表示角位移的t倍</p><p><img src=https://i.ibb.co/jWRK1mJ/image-20220622154310060.png loading=lazy alt=image-20220622154310060></p></li></ul><h3 id=四元数插值>四元数插值</h3><h4 id=slerp插值>Slerp插值</h4><p>开始四元数q0和结束四元数q1,差值参数t，0≤t ≤1，slerp(q0,q1,t)返回q0到q1间的方位</p><p><img src=https://i.ibb.co/QvxzsrT/image-20220622154907238.png loading=lazy alt=image-20220622154907238></p><p>简化</p><p><img src=https://i.ibb.co/LZ6Qtq0/image-20220622155729925.png loading=lazy alt=image-20220622155729925></p><ul><li>四元数加法（实部实部相加，虚部虚部相加），要考虑两个四元数w方向是否相同。如果相反则改为相减。</li><li>k0+k1≠1，因此插值后的四元数模不为1，需要单位化后使用</li></ul><h4 id=squad插值>Squad插值</h4><p>实现多个方位角之间的平滑序列，不介绍</p><h2 id=视点控制>视点控制</h2><p>glRotated(-m_hpb[2],0,0,1); //b 绕z轴转
glRotated(-m_hpb[1],1,0,0); //p 绕x轴转
glRotated(-m_hpb[0],0,1,0); //h 绕y轴转
glTranslated(-m_pos.x,-m_pos.y,-m_pos.z);
视点位置记录在m_pos,视点方位角在m_hpb</p><h2 id=包围盒>包围盒</h2><p>AABB（axially aligned bounding box)</p><ul><li>对变换后物体重新计算AABB</li><li>对AABB做和物体相同变换(不保证轴对齐，非AABB)</li></ul><h2 id=光照>光照</h2><ul><li>启动光照
glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);</li><li>创建光源
glLight{if}[v](GLenum light , GLenum pname, TYPE param)
Pname:
GL_AMBIENT 环境反射
GL_DIFFUSE 漫反射
GL_SPECULAR 镜面反射
GL_POSITION 当第w位为0时表示平行光源，为1表示点光源</li><li></li></ul><h2 id=纹理>纹理</h2><h2 id=特殊效果>特殊效果</h2><h2 id=opengl内部矩阵>OpenGL内部矩阵</h2><h3 id=gl_modelview模型视图矩阵>GL_MODELVIEW（模型视图矩阵）</h3><p>把空间点从<strong>模型坐标系</strong>最终变换到<strong>眼坐标系</strong>下，包括视图矩阵和模型矩阵的两个矩阵的乘积，在绘制对象的时候执行变换，把glBegin和glEnd之间的顶点乘以当前模型视图矩阵得到眼坐标系下的空间坐标。</p><h3 id=gl_projection投影矩阵>GL_PROJECTION（投影矩阵）</h3><p>把<strong>眼空间坐标系</strong>下的视锥体内点转变到<strong>矩形规范体</strong>（裁剪坐标系）内的点坐标。便于后续操作。转换后的坐标范围是(-1,-1,-1)~(1,1,1)。范围外点不在视锥体内，要被裁剪掉，包括透视投影或者平行投影两类。</p><p>裁剪坐标=投影矩阵*眼坐标
投影结果：x∈[-1,1] y∈[-1,1] z∈[-1,1]
z转换到0~1区间后存入深度缓冲：z’=(z+1)*0.5</p><h3 id=gl_texture纹理矩阵>GL_TEXTURE（纹理矩阵）</h3><h2 id=opengl函数>OpenGL函数</h2><h3 id=glreadpixels>glReadPixels</h3><h3 id=glutinitdisplaymodeunsigned-int-mode>glutInitDisplayMode(unsigned int mode);</h3><p>设置初始显示模式</p><div class=table-wrapper><table><thead><tr><th>值</th><th>对应宏定义</th><th>意义</th></tr></thead><tbody><tr><td>GLUT_RGB</td><td>0x0000</td><td>指定 <a class=link href=https://baike.baidu.com/item/RGB target=_blank rel=noopener>RGB</a> 颜色模式的窗口</td></tr><tr><td>GLUT_RGBA</td><td>0x0000</td><td>指定 <a class=link href=https://baike.baidu.com/item/RGBA target=_blank rel=noopener>RGBA</a> 颜色模式的窗口</td></tr><tr><td>GLUT_INDEX</td><td>0x0001</td><td>指定颜色索引模式的窗口</td></tr><tr><td>GLUT_SINGLE</td><td>0x0000</td><td>指定单缓存窗口</td></tr><tr><td>GLUT_DOUBLE</td><td>0x0002</td><td>指定双缓存窗口</td></tr><tr><td>GLUT_ACCUM</td><td>0x0004</td><td>窗口使用累加缓存</td></tr><tr><td>GLUT_ALPHA</td><td>0x0008</td><td>窗口的颜色分量包含 alpha 值</td></tr><tr><td>GLUT_DEPTH</td><td>0x0010</td><td>窗口使用深度缓存</td></tr><tr><td>GLUT_STENCIL</td><td>0x0020</td><td>窗口使用模板缓存</td></tr><tr><td>GLUT_MULTISAMPLE</td><td>0x0080</td><td>指定支持多样本功能的窗口</td></tr><tr><td>GLUT_STEREO</td><td>0x0100</td><td>指定立体窗口</td></tr><tr><td>GLUT_LUMINANCE</td><td>0x0200</td><td>窗口使用亮度颜色模型</td></tr></tbody></table></div><h3 id=glclearcolorrbga>glClearColor(r,b,g,a);</h3><p>背景颜色</p><h3 id=glclearglbitfield-mask>glClear(GLbitfield mask);</h3><p>GLbitfield：可以使用 | 运算符组合不同的缓冲标志位，表明<strong>需要清除的缓冲</strong>，例如glClear（GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT）表示要清除颜色缓冲以及深度缓冲，可以使用以下标志位</p><pre tabindex=0><code>  GL_COLOR_BUFFER_BIT:    颜色缓冲
  GL_DEPTH_BUFFER_BIT:    深度缓冲
  GL_ACCUM_BUFFER_BIT:   累积缓冲
  GL_STENCIL_BUFFER_BIT: 模板缓冲
</code></pre><p>　也就是用glClearColor或者glClearDepth、glClearIndex、glClearStencil、glClearAccum等函数所指定的值来清除指定的缓冲区</p><h3 id=glflushglfinish>glFlush()/glFinish()</h3><p>强制刷新缓冲，保证绘图命令将被执行</p><h3 id=glswapbuffer>glSwapBuffer()</h3><h3 id=glbegin>glBegin();</h3><p>glBegin表示一组用于定义一个或者多个图元的顶点的开始</p><pre tabindex=0><code>GL_POINTS 			单个顶点集

GL_LINES 			多组双顶点线段,如果顶点数为奇数，最后一个顶点就会被忽略。 
GL_LINE_STRIP 		不闭合折线
GL_LINE_LOOP 		闭合折线
GL_POLYGON 			单个简单填充凸多边形

GL_TRIANGLES 		多组独立填充三角形
GL_TRIANGLE_STRIP 	线型连续填充三角形串
GL_TRIANGLE_FAN 	扇形连续填充三角形串


GL_QUADS 			多组独立填充四边形
GL_QUAD_STRIP 		连续填充四边形串
</code></pre><p>glTranslatef()等此类几何转换接口在glBegin()和glEnd()之间是无效的。因此，如果想对模型的位置进行转换，要在调用glBegin()和glEnd()接口对之前行处理。</p><pre tabindex=0><code>在glBegin()和glEnd()之间可调用的函数如下：
glVertex()：设置顶点坐标 　　 

glColor()：设置当前颜色 　 

glIndex()：设置当前颜色表 　 

glNormal()：设置法向坐标 　 

glEvalCoord()：产生坐标 　 

glCallList()、glCallLists()：执行显示列表 　 

glTexCoord()：设置纹理坐标 　 

glEdgeFlag()：控制边界绘制 　 

glMaterial()：设置材质　
</code></pre><h3 id=glend>glEnd();</h3><p>glEnd表示一组用于定义一个或者多个图元的顶点的结束</p><h3 id=glenable>glEnable():</h3><p>用于启用各种功能。功能由参数决定</p><div class=table-wrapper><table><thead><tr><th>类型</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>GL_ALPHA_TEST</td><td>4864</td><td>跟据函数<a class=link href=http://www.cx2012.com/Article/ArText129562173721267500ID146.html target=_blank rel=noopener>glAlphaFunc</a>的条件要求来决定图形透明的层度是否显示</td></tr><tr><td>GL_AUTO_NORMAL</td><td>3456</td><td>执行后，图形能把光反射到各个方向</td></tr><tr><td>GL_BLEND</td><td>3042</td><td>启用颜色混合。例如实现半透明效果</td></tr><tr><td>GL_CLIP_PLANE0 ~ GL_CLIP_PLANE5</td><td>12288 ~ 12283</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129562975344837500ID147.html target=_blank rel=noopener>glClipPlane</a>的条件要求 启用图形切割管道。这里指六种缓存管道</td></tr><tr><td>GL_COLOR_LOGIC_OP</td><td>3058</td><td>启用每一像素的色彩为位逻辑运算</td></tr><tr><td>GL_COLOR_MATERIAL</td><td>2930</td><td>执行后，图形（材料）将根据光线的照耀进行反射 反射要求由函数<a class=link href=http://www.cx2012.com/Article/ArText129563854289985000ID148.html target=_blank rel=noopener>glColorMaterial</a>进行设定</td></tr><tr><td>GL_CULL_FACE</td><td>2884</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129564426328125000ID149.html target=_blank rel=noopener>glCullFace</a>要求启用隐藏图形材料的面</td></tr><tr><td>GL_DEPTH_TEST</td><td>2929</td><td>启用深度测试 根据坐标的远近自动隐藏被遮住的图形（材料）</td></tr><tr><td>GL_DITHER</td><td>3024</td><td>启用抖动</td></tr><tr><td>GL_FOG</td><td>2912</td><td>雾化效果 例如距离越远越模糊</td></tr><tr><td>GL_INDEX_LOGIC_OP</td><td>3057</td><td>逻辑操作</td></tr><tr><td>GL_LIGHT0 ~ GL_LIGHT7</td><td>16384 ~ 16391</td><td>启用0号灯到7号灯(光源) 光源要求由函数<a class=link href=http://www.cx2012.com/Article/ArText129564581700000000ID150.html target=_blank rel=noopener>glLight</a>函数来完成</td></tr><tr><td>GL_LIGHTING</td><td>2896</td><td>启用灯源</td></tr><tr><td>GL_LINE_SMOOTH</td><td>2848</td><td>执行后，过虑线段的锯齿</td></tr><tr><td>GL_LINE_STIPPLE</td><td>2852</td><td>执行后，画虚线</td></tr><tr><td>GL_LOGIC_OP</td><td>3057</td><td>逻辑操作</td></tr><tr><td>GL_MAP1_COLOR_4</td><td>3472</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 生成RGBA曲线</td></tr><tr><td>GL_MAP1_INDEX</td><td>3473</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 生成颜色索引曲线</td></tr><tr><td>GL_MAP1_NORMAL</td><td>3474</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 生成法线</td></tr><tr><td>GL_MAP1_TEXTURE_COORD_1</td><td>3475</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 生成文理坐标</td></tr><tr><td>GL_MAP1_TEXTURE_COORD_2</td><td>3476</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 生成文理坐标</td></tr><tr><td>GL_MAP1_TEXTURE_COORD_3</td><td>3477</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 生成文理坐标</td></tr><tr><td>GL_MAP1_TEXTURE_COORD_4</td><td>3478</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用glEvalCoord1,glEvalMesh1,glEvalPoint1 生成文理坐标</td></tr><tr><td>GL_MAP1_VERTEX_3</td><td>3479</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 在三维空间里生成曲线</td></tr><tr><td>GL_MAP1_VERTEX_4</td><td>3480</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map1</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord1</a>,glEvalMesh1,glEvalPoint1 在四维空间里生成法线</td></tr><tr><td>GL_MAP2_COLOR_4</td><td>3504</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 生成RGBA曲线</td></tr><tr><td>GL_MAP2_INDEX</td><td>3505</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 生成颜色索引</td></tr><tr><td>GL_MAP2_NORMAL</td><td>3506</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 生成法线</td></tr><tr><td>GL_MAP2_TEXTURE_COORD_1</td><td>3507</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 生成纹理坐标</td></tr><tr><td>GL_MAP2_TEXTURE_COORD_2</td><td>3508</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 生成纹理坐标</td></tr><tr><td>GL_MAP2_TEXTURE_COORD_3</td><td>3509</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 生成纹理坐标</td></tr><tr><td>GL_MAP2_TEXTURE_COORD_4</td><td>3510</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 生成纹理坐标</td></tr><tr><td>GL_MAP2_VERTEX_3</td><td>3511</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 在三维空间里生成曲线</td></tr><tr><td>GL_MAP2_VERTEX_4</td><td>3512</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129566170546093750ID151.html target=_blank rel=noopener>Map2</a>对贝赛尔曲线的设置， 启用<a class=link href=http://www.cx2012.com/Article/ArText129566173102187500ID152.html target=_blank rel=noopener>glEvalCoord2</a>,glEvalMesh2,glEvalPoint2 在三维空间里生成曲线</td></tr><tr><td>GL_NORMALIZE</td><td>2977</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129567069415160000ID153.html target=_blank rel=noopener>glNormal</a>的设置条件，启用法向量</td></tr><tr><td>GL_POINT_SMOOTH</td><td>2832</td><td>执行后，过虑线点的锯齿</td></tr><tr><td>GL_POLYGON_OFFSET_FILL</td><td>32823</td><td>根据函数glPolygonOffset的设置，启用面的深度偏移</td></tr><tr><td>GL_POLYGON_OFFSET_LINE</td><td>10754</td><td>根据函数glPolygonOffset的设置，启用线的深度偏移</td></tr><tr><td>GL_POLYGON_OFFSET_POINT</td><td>10753</td><td>根据函数glPolygonOffset的设置，启用点的深度偏移</td></tr><tr><td>GL_POLYGON_SMOOTH</td><td>2881</td><td>过虑图形（多边形）的锯齿</td></tr><tr><td>GL_POLYGON_STIPPLE</td><td>2882</td><td>执行后，多边形为矢量画图</td></tr><tr><td>GL_SCISSOR_TEST</td><td>3089</td><td>根据函数<a class=link href=http://www.cx2012.com/Article/ArText129568692124062500ID155.html target=_blank rel=noopener>glScissor</a>设置，启用图形剪切</td></tr><tr><td>GL_STENCIL_TEST</td><td>2960</td><td>启用模板测试</td></tr><tr><td>GL_TEXTURE_1D</td><td>3552</td><td>启用一维文理</td></tr><tr><td>GL_TEXTURE_2D</td><td>3553</td><td>启用二维文理</td></tr><tr><td>GL_TEXTURE_GEN_Q</td><td>3171</td><td>根据函数glTexGen，启用纹理处理</td></tr><tr><td>GL_TEXTURE_GEN_R</td><td>3170</td><td>根据函数glTexGen，启用纹理处理</td></tr><tr><td>GL_TEXTURE_GEN_S</td><td>3168</td><td>根据函数glTexGen，启用纹理处理</td></tr><tr><td>GL_TEXTURE_GEN_T</td><td>3169</td><td>根据函数glTexGen，启用纹理处理</td></tr></tbody></table></div><h3 id=gldisable>glDisable()</h3><p>用来关闭的。与glDisable()参数一致</p><h3 id=glshademodel>glShadeModel()</h3><p>参数mode可以是GL_SMOOTH（默认值）或GL_FLAT。采用恒定着色时（即GL_FLAT），使用图元中某个顶点的颜色来渲染整个图元。
在使用光滑着色时（即GL_SMOOTH），独立的处理图元中各个顶点的颜色。对于线段图元，线段上各点的颜色将根据两个顶点的颜色通过差值得到。对于多边形图元，多边形内部区域的颜色将根据所有顶点的颜色差值得到。</p><h3 id=glfrontfaceglenum-mode><strong>glFrontFace</strong>(GLenum <em>mode</em>)</h3><p>作用是控制多边形的正面是如何决定的</p><p>GL_CCW 表示窗口坐标上投影多边形的顶点顺序为逆时针方向的表面为正面。</p><p>GL_CW 表示顶点顺序为顺时针方向的表面为正面。</p><p>在默认情况下，mode是GL_CCW</p><h3 id=glpolygonmodeglenum-faceglenum-mode>glPolygonMode(GLenum face,GLenum mode)</h3><ul><li><p>face这个参数确定显示模式将适用于物体的哪些部分，控制多边形的正面和背面的绘图模式：</p><p>GL_FRONT表示显示模式将适用于物体的前向面（也就是物体能看到的面）</p><p>GL_BACK表示显示模式将适用于物体的后向面（也就是物体上不能看到的面）</p><p>GL_FRONT_AND_BACK表示显示模式将适用于物体的所有面</p></li><li><p>mode这个参数确定选中的物体的面以何种方式显示（显示模式）：</p><p>GL_POINT表示显示顶点，多边形用点显示</p><p>GL_LINE表示显示线段，多边形用轮廓显示</p><p>GL_FILL表示显示面，多边形采用填充形式</p></li></ul><h3 id=gltranslatefxyz>glTranslatef(x,y,z)</h3><p>沿X轴正方向平移x个单位(x是有符号数)</p><p>沿Y轴正方向平移y个单位(y是有符号数)</p><p>沿Z轴正方向平移z个单位(z是有符号数)</p><p><img src=https://i.ibb.co/jJfcHVs/image-20220519165435701.png loading=lazy alt=image-20220519165435701></p><h3 id=glscalefxyz>glScalef(x,y,z)</h3><p><img src=https://i.ibb.co/yyv57WT/image-20220519165740518.png loading=lazy alt=image-20220519165740518></p><h3 id=glrotatefangleabc>glRotatef(angle,a,b,c)</h3><p>绕过原点与（a,b,c）的轴正方向旋转angle度</p><p><img src=https://i.ibb.co/r7SZ6S0/image-20220520150625381.png loading=lazy alt=image-20220520150625381></p><p><img src=https://i.ibb.co/W0DZqH0/image-20220519170552122.png loading=lazy alt=image-20220519170552122></p><h3 id=glloadidentity><strong>glLoadIdentity()</strong></h3><p>重置当前指定的矩阵为单位矩阵</p><p>glViewport(GLint x,GLint y,GLsizei width, GLsizei height);</p><p>左下角坐标，宽，高</p><h3 id=glclipplaneglenum-planeconst-gldouble-equation>glClipPlane(GLenum plane,Const GLdouble *equation);</h3><p>定义一个裁剪平面，quation参数指向平面方程Ax + By + Cz + D = 0的4个系数。</p><h3 id=gluunproject>gluUnProject()</h3><p>int WINAPI gluUnProject(
GLdouble winx,
GLdouble winy,
GLdouble winz,
const GLdouble modelMatrix[16],
const GLdouble projMatrix[16],
const GLint viewport[4],
GLdouble *objx,
GLdouble *objy,
GLdouble *objz
);</p><p>(winx,winy,winz)为要映射的窗口坐标</p><p>(objx,objy,objz)为计算的 x</p><p>modelview 矩阵从 glGetDoublev 调用</p><p>projMatrix投影矩阵从 glGetDoublev 调用</p><p>视区从 glGetIntegerv 调用</p><h3 id=glulookat>gluLookAt()</h3><pre tabindex=0><code>gluLookAt(GLdouble eyex,GLdouble eyey,GLdouble eyez,GLdouble centerx,GLdouble centery,GLdouble centerz,GLdouble upx,GLdouble upy,GLdouble upz);
</code></pre><p>第一组eyex, eyey,eyez 相机在世界坐标的位置</p><p>第二组centerx,centery,centerz <a class=link href=https://baike.baidu.com/item/%e7%9b%b8%e6%9c%ba%e9%95%9c%e5%a4%b4/10294376 target=_blank rel=noopener>相机镜头</a>对准的物体在世界坐标的位置</p><p>第三组upx,upy,upz 相机向上的方向在世界坐标中的方向</p><p>你把相机想象成为你自己的脑袋：</p><p>第一组数据就是脑袋的位置</p><p>第二组数据就是眼睛看的物体的位置</p><p>第三组就是头顶朝向的方向（因为你可以歪着头看同一个物体）</p><h3 id=gluperspectivegldouble-fovy-gldouble-aspect-gldouble-znear-gldouble-zfar->gluPerspective(GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar );</h3><p>fovy 上平面与下平面的夹角°
aspect 屏幕的宽高比
zNear 近视点距离
zFar 远视点距离</p><h3 id=void-glortho-gldouble-left-gldouble-right-gldouble-bottom-gldouble-top-gldouble-znear-gldouble-zfar->void glOrtho( GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar );</h3><p>正交投影</p><h3 id=glpushmatrix>glPushMatrix()</h3><p>将当前矩阵保存入<a class=link href=https://baike.baidu.com/item/%e5%a0%86%e6%a0%88 target=_blank rel=noopener>堆栈</a>顶(保存当前矩阵)</p><h3 id=glpopmatrix>glPopMatrix()</h3><p>当经过一系列的变换后，栈顶矩阵被修改，此时调用glPopMatrix()时，栈顶矩阵被弹出，且又会恢复为原来的状态。glPushMatrix()和glPopMatrix()的配对使用可以消除上一次的变换对本次变换的影响。使本次变换是以世界坐标系的原点为参考点进行。</p><h3 id=glmatrixmode>glMatrixMode()</h3><p>mode 指定哪一个矩阵堆栈是下一个矩阵操作的目标,可选值:</p><ul><li>GL_MODELVIEW,对模型视图矩阵堆栈应用随后的矩阵操作。可以在执行此命令后，输出自己的物体图形了。</li><li>GL_PROJECTION,对投影矩阵堆栈应用随后的矩阵操作。可以在执行此命令后，为我们的场景增加透视。</li><li>GL_TEXTURE,对纹理矩阵堆栈应用随后的矩阵操作。可以在执行此命令后，为我们的图形增加纹理贴图。</li></ul><h3 id=glloadmatrixfm>glLoadMatrixf(M)</h3><p>replace the current <a class=link href="https://so.csdn.net/so/search?q=matrix&amp;spm=1001.2101.3001.7020" target=_blank rel=noopener>matrix</a> with an arbitrary matrix M</p><h3 id=glmultmatrixfm>glMultMatrixf(M)</h3><p>将当前矩阵乘以任意矩阵</p><h3 id=glkeybordfuncunsigned-char-keyint-xint-y>glKeybordFunc(unsigned char key,int x,int y)</h3><p>键盘回调函数</p><h3 id=gluttimerfuncunsigned-int-millis-void-funcint-value-int-value>glutTimerFunc(unsigned int millis, void (*func)(int value), int value)</h3><p>调用毫秒数，回调Timer，Timer的标识值</p><p>其真实意义是在millis毫秒后回调Timer,因此应在回调Timer中重新调用该函数以形成循环</p></section><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><section class=article-lastmod><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>Last updated on Jun 06, 2023 00:00 UTC</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/software-architecturenotes/><div class=article-details><h2 class=article-title>【Software Architecture】Notes</h2></div></a></article><article><a href=/p/computer-architecturenotes/><div class=article-details><h2 class=article-title>【Computer Architecture】Notes</h2></div></a></article><article><a href=/p/computer-networknotes/><div class=article-details><h2 class=article-title>【Computer Network】Notes</h2></div></a></article><article><a href=/p/computer-visionnotes/><div class=article-details><h2 class=article-title>【Computer Vision】Notes</h2></div></a></article><article><a href=/p/stanford-compilersnotes/><div class=article-details><h2 class=article-title>【Stanford Compilers】Notes</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//hugo-theme-stack.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 飞鸿踏雪泥</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>